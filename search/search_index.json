{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Maeson: Making Awesome Earth Science presentatiONs","text":"<p>Welcome to Maeson, the all-in-one geospatial toolkit for creating, editing, and sharing dynamic Earth science narratives directly within your Jupyter environment. Maeson simplifies complex geospatial workflows by uniting data processing, visualization, and interactive storytelling into a single, cohesive package.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\ud83d\ude80 Rapid Scene Creation: Define map extents, set zoom levels, and add diverse layers (GeoJSON, raster, tile, WMS, imagery, video, and Earth Engine) with just a few lines of Python.</li> <li>\ud83d\udd04 Live Previews: Instantly render and update layers in-place. Tweak layer parameters or custom scripts and see changes reflected on the map in real time.</li> <li>\ud83d\udd27 Custom Code Integration: Write arbitrary Python snippets (e.g., Earth Engine calls, heatmaps, analytics) in the embedded code editor, execute them on your map, and save them alongside each scene.</li> <li>\ud83d\udcd1 Structured Storytelling: Organize multiple scenes into an ordered sequence, annotate with titles and metadata, and export your narrative as JSON for later reuse or publication.</li> <li>\ud83d\udcca Presentation Mode: Switch seamlessly from authoring to playback. Advance through your scenes with Next/Back controls, focusing your audience on the evolving map story.</li> <li>\ud83c\udfa8 Interactive Bounds Editing: Adjust image and video overlays by dragging or via sliders\u2014no need to recode bounds manually.</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<pre><code>import maeson\nfrom maeson import Map, StoryBuilder, StoryTeller\n\n# 1. Initialize your map\nm = Map(center=(37.77, -122.42), zoom=10)\n\n# 2. Launch the story builder\nbuilder = StoryBuilder(m)\nbuilder.display()\n\n# 3. Add layers, set titles, and preview interactively\n# 4. Save scenes and switch to presentation mode\n</code></pre>"},{"location":"#example-workflow","title":"Example Workflow","text":"<ol> <li>Load data: Use <code>m.add_geojson()</code>, <code>m.add_raster()</code>, or custom Earth Engine calls in the code editor.</li> <li>Preview: Click Preview to render layers and auto-zoom to extents.</li> <li>Save: Title and save your scene\u2014Maeson persists both the map state and any custom code.</li> <li>Copy &amp; Clear: Duplicate or clear layers between scenes for iterative storytelling.</li> <li>Present: Hit Present to enter an uncluttered playback interface.</li> </ol>"},{"location":"#extensibility","title":"Extensibility","text":"<p>Maeson\u2019s modular design lets you:</p> <ul> <li>Hook into additional mapping libraries (e.g., Leafmap, MapLibre)</li> <li>Integrate new layer types or data sources</li> <li>Customize UI components to match your workflow</li> </ul> <p>Maeson: Making Awesome Earth Science Presentations \u2014 your one-stop solution for geospatial storytelling.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v003-date","title":"v0.0.3 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"common/","title":"common module","text":"<p>The common module contains common functions and classes used by the other modules.</p>"},{"location":"common/#maeson.common.hello_world","title":"<code>hello_world()</code>","text":"<p>Prints \"Hello World!\" to the console.</p> Source code in <code>maeson/common.py</code> <pre><code>def hello_world():\n    \"\"\"Prints \"Hello World!\" to the console.\"\"\"\n    print(\"Hello World!\")\n</code></pre>"},{"location":"contributing/","title":"Contributing to MAESon \ud83e\udd1d\ud83d\ude80","text":"<p>Thank you for your interest in contributing to MAESon! We welcome contributions of all kinds, including bug fixes, new features, documentation improvements, and discussions.</p>"},{"location":"contributing/#how-to-contribute","title":"How to Contribute \ud83d\udccc","text":""},{"location":"contributing/#1-fork-the-repository","title":"1. Fork the Repository","text":"<p>Click the Fork button at the top of the MAESon GitHub repository, and clone it to your local machine: <pre><code>git clone https://github.com/yourusername/MAESon.git\ncd MAESon\n</code></pre></p>"},{"location":"contributing/#2-create-a-branch","title":"2. Create a Branch","text":"<p>Create a new branch for your feature or bug fix: <pre><code>git checkout -b feature-xyz\n</code></pre></p>"},{"location":"contributing/#3-install-dependencies","title":"3. Install Dependencies","text":"<p>Ensure you have all necessary dependencies installed: <pre><code>pip install -r requirements.txt\n</code></pre> For development, install additional dependencies: <pre><code>pip install -r requirements-dev.txt\n</code></pre></p>"},{"location":"contributing/#4-make-your-changes","title":"4. Make Your Changes","text":"<p>Modify the codebase and test your changes. If adding a new feature, update the documentation accordingly.</p>"},{"location":"contributing/#5-run-tests","title":"5. Run Tests \u2705","text":"<p>Ensure all tests pass before submitting a pull request: <pre><code>pytest\n</code></pre></p>"},{"location":"contributing/#6-commit-and-push-changes","title":"6. Commit and Push Changes","text":"<pre><code>git add .\ngit commit -m \"Add feature XYZ\"\ngit push origin feature-xyz\n</code></pre>"},{"location":"contributing/#7-submit-a-pull-request","title":"7. Submit a Pull Request","text":"<p>Go to the MAESon repository on GitHub, navigate to the Pull Requests tab, and submit a new pull request. Provide a clear description of the changes you've made.</p>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues \ud83d\udc1e","text":"<p>If you encounter a bug, please report it by opening an issue on GitHub Issues. Provide as much detail as possible, including: - Steps to reproduce the issue - Expected behavior - Actual behavior - Screenshots or error logs (if applicable)</p>"},{"location":"contributing/#code-style-guidelines","title":"Code Style Guidelines \u2728","text":"<ul> <li>Follow PEP 8 for Python code style.</li> <li>Use type hints where applicable.</li> <li>Write docstrings for all functions and classes.</li> </ul>"},{"location":"contributing/#documentation-contributions","title":"Documentation Contributions \ud83d\udcd6","text":"<p>We also welcome contributions to our documentation! If you'd like to improve or add new sections, edit the markdown files in the <code>docs/</code> directory and submit a pull request.</p>"},{"location":"contributing/#join-the-discussion","title":"Join the Discussion \ud83d\udcac","text":"<p>Want to discuss a feature before implementing it? Join the Discussions tab or open an issue to propose new ideas!</p> <p>\ud83d\ude80 Thank you for contributing to MAESon! Your support helps make geospatial AI more accessible and powerful.</p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"folmap/","title":"<code>folmap</code>","text":"<p>Folium Module</p>"},{"location":"folmap/#maeson.folmap.Map","title":"<code> Map            (Map)         </code>","text":"<p>class that extends folium.Map. This class is used to create a map with additional functionalities.</p> Source code in <code>maeson/folmap.py</code> <pre><code>class Map(folium.Map):\n    \"\"\"\n    class that extends folium.Map.\n    This class is used to create a map with additional functionalities.\n    \"\"\"\n\n    def __init__(self, center=(0, 0), zoom=2, **kwargs):\n        super().__init__(location=center, zoom_start=zoom, **kwargs)\n\n    def add_basemap(self, name: str, **kwargs):\n        \"\"\"\n        Add a basemap to the map using Esri maps.\n        Args:\n            name (str): Name of the basemap.\n            **kwargs: Additional arguments to pass to the folium.TileLayer.\n        \"\"\"\n        basemaps = {\n            \"Road\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}\",\n            \"Satellite\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\",\n            \"Topo\": \"https://server.arcgisonline.com/ArcGIS/rest/services/Topographic/MapServer/tile/{z}/{y}/{x}\",\n            \"Terrain\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Terrain_Base/MapServer/tile/{z}/{y}/{x}\",\n        }\n        if name in basemaps:\n            folium.TileLayer(\n                tiles=basemaps[name],\n                attr='&amp;copy; &lt;a href=\"http://www.esri.com/\"&gt;Esri&lt;/a&gt;',\n                **kwargs,\n            ).add_to(self)\n        else:\n            raise ValueError(f\"Basemap '{name}' not found.\")\n\n    def add_geojson(self, data, name=\"GeoJSON Layer\", **kwargs):\n        \"\"\"Adds a GeoJSON layer to the map.\n\n        Args:\n            data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n            name (str): Name of the layer to display in the LayerControl. Defaults to \"GeoJSON Layer\".\n            **kwargs: Additional keyword arguments for the folium.GeoJson layer.\n        \"\"\"\n        import geopandas as gpd\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            geojson = gdf.__geo_interface__\n        elif isinstance(data, dict):\n            geojson = data\n\n        geojson_layer = folium.GeoJson(data=geojson, name=name, **kwargs)\n        geojson_layer.add_to(self)\n\n    def add_shp(self, data, **kwargs):\n        \"\"\"Adds a shapefile to the map.\n\n        Args:\n            data (str): The file path to the shapefile.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        import geopandas as gpd\n\n        gdf = gpd.read_file(data)\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_gdf(self, gdf, name=\"GDF Layer\", **kwargs):\n        \"\"\"Adds a GeoDataFrame to the map.\n\n        Args:\n            gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n        \"\"\"\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, name, **kwargs)\n\n    def add_vector(self, data, name=\"Vector Layer\", **kwargs):\n        \"\"\"Adds vector data to the map.\n\n        Args:\n            data (str, geopandas.GeoDataFrame, or dict): The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.\n            name (str): Name of the layer to display in the LayerControl. Defaults to \"Vector Layer\".\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            self.add_gdf(gdf, name=name, **kwargs)\n        elif isinstance(data, gpd.GeoDataFrame):\n            self.add_gdf(data, name=name, **kwargs)\n        elif isinstance(data, dict):\n            self.add_geojson(data, name=name, **kwargs)\n        else:\n            raise ValueError(\"Invalid data type\")\n\n    def add_layer_control(self):\n        \"\"\"Adds a layer control widget to the map.\"\"\"\n        folium.LayerControl().add_to(self)\n\n    def add_raster(self, data: str, layer_name: str, **kwargs):\n        \"\"\"\n        Add a raster layer to the map.\n        Args:\n            data (str): Path to the raster file.\n            layer_name (str): Name of the layer.\n            **kwargs: Additional arguments to pass to the folium.ImageOverlay.\n        \"\"\"\n        folium.ImageOverlay(data, name=layer_name, **kwargs).add_to(self)\n\n    def add_split_map(self, left=\"openstreetmap\", right=\"cartodbpositron\", **kwargs):\n\n        layer_right = folium.TileLayer(left, **kwargs)\n        layer_left = folium.TileLayer(right, **kwargs)\n\n        sbs = folium.plugins.SideBySideLayers(\n            layer_left=layer_left, layer_right=layer_right\n        )\n\n        # Allow for raster TIFs to be added to left or right\n        if isinstance(left, str) and left.endswith(\".tif\"):\n            layer_left = folium.ImageOverlay(left, **kwargs)\n        if isinstance(right, str) and right.endswith(\".tif\"):\n            layer_right = folium.ImageOverlay(right, **kwargs)\n\n        layer_left.add_to(self)\n        layer_right.add_to(self)\n        sbs.add_to(self)\n</code></pre>"},{"location":"folmap/#maeson.folmap.Map.add_basemap","title":"<code>add_basemap(self, name, **kwargs)</code>","text":"<p>Add a basemap to the map using Esri maps.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the basemap.</p> required <code>**kwargs</code> <p>Additional arguments to pass to the folium.TileLayer.</p> <code>{}</code> Source code in <code>maeson/folmap.py</code> <pre><code>def add_basemap(self, name: str, **kwargs):\n    \"\"\"\n    Add a basemap to the map using Esri maps.\n    Args:\n        name (str): Name of the basemap.\n        **kwargs: Additional arguments to pass to the folium.TileLayer.\n    \"\"\"\n    basemaps = {\n        \"Road\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}\",\n        \"Satellite\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\",\n        \"Topo\": \"https://server.arcgisonline.com/ArcGIS/rest/services/Topographic/MapServer/tile/{z}/{y}/{x}\",\n        \"Terrain\": \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Terrain_Base/MapServer/tile/{z}/{y}/{x}\",\n    }\n    if name in basemaps:\n        folium.TileLayer(\n            tiles=basemaps[name],\n            attr='&amp;copy; &lt;a href=\"http://www.esri.com/\"&gt;Esri&lt;/a&gt;',\n            **kwargs,\n        ).add_to(self)\n    else:\n        raise ValueError(f\"Basemap '{name}' not found.\")\n</code></pre>"},{"location":"folmap/#maeson.folmap.Map.add_gdf","title":"<code>add_gdf(self, gdf, name='GDF Layer', **kwargs)</code>","text":"<p>Adds a GeoDataFrame to the map.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>geopandas.GeoDataFrame</code> <p>The GeoDataFrame to add.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>maeson/folmap.py</code> <pre><code>def add_gdf(self, gdf, name=\"GDF Layer\", **kwargs):\n    \"\"\"Adds a GeoDataFrame to the map.\n\n    Args:\n        gdf (geopandas.GeoDataFrame): The GeoDataFrame to add.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, name, **kwargs)\n</code></pre>"},{"location":"folmap/#maeson.folmap.Map.add_geojson","title":"<code>add_geojson(self, data, name='GeoJSON Layer', **kwargs)</code>","text":"<p>Adds a GeoJSON layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str or dict</code> <p>The GeoJSON data. Can be a file path (str) or a dictionary.</p> required <code>name</code> <code>str</code> <p>Name of the layer to display in the LayerControl. Defaults to \"GeoJSON Layer\".</p> <code>'GeoJSON Layer'</code> <code>**kwargs</code> <p>Additional keyword arguments for the folium.GeoJson layer.</p> <code>{}</code> Source code in <code>maeson/folmap.py</code> <pre><code>def add_geojson(self, data, name=\"GeoJSON Layer\", **kwargs):\n    \"\"\"Adds a GeoJSON layer to the map.\n\n    Args:\n        data (str or dict): The GeoJSON data. Can be a file path (str) or a dictionary.\n        name (str): Name of the layer to display in the LayerControl. Defaults to \"GeoJSON Layer\".\n        **kwargs: Additional keyword arguments for the folium.GeoJson layer.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        geojson = gdf.__geo_interface__\n    elif isinstance(data, dict):\n        geojson = data\n\n    geojson_layer = folium.GeoJson(data=geojson, name=name, **kwargs)\n    geojson_layer.add_to(self)\n</code></pre>"},{"location":"folmap/#maeson.folmap.Map.add_layer_control","title":"<code>add_layer_control(self)</code>","text":"<p>Adds a layer control widget to the map.</p> Source code in <code>maeson/folmap.py</code> <pre><code>def add_layer_control(self):\n    \"\"\"Adds a layer control widget to the map.\"\"\"\n    folium.LayerControl().add_to(self)\n</code></pre>"},{"location":"folmap/#maeson.folmap.Map.add_raster","title":"<code>add_raster(self, data, layer_name, **kwargs)</code>","text":"<p>Add a raster layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>Path to the raster file.</p> required <code>layer_name</code> <code>str</code> <p>Name of the layer.</p> required <code>**kwargs</code> <p>Additional arguments to pass to the folium.ImageOverlay.</p> <code>{}</code> Source code in <code>maeson/folmap.py</code> <pre><code>def add_raster(self, data: str, layer_name: str, **kwargs):\n    \"\"\"\n    Add a raster layer to the map.\n    Args:\n        data (str): Path to the raster file.\n        layer_name (str): Name of the layer.\n        **kwargs: Additional arguments to pass to the folium.ImageOverlay.\n    \"\"\"\n    folium.ImageOverlay(data, name=layer_name, **kwargs).add_to(self)\n</code></pre>"},{"location":"folmap/#maeson.folmap.Map.add_shp","title":"<code>add_shp(self, data, **kwargs)</code>","text":"<p>Adds a shapefile to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The file path to the shapefile.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>maeson/folmap.py</code> <pre><code>def add_shp(self, data, **kwargs):\n    \"\"\"Adds a shapefile to the map.\n\n    Args:\n        data (str): The file path to the shapefile.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n    \"\"\"\n    import geopandas as gpd\n\n    gdf = gpd.read_file(data)\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"folmap/#maeson.folmap.Map.add_vector","title":"<code>add_vector(self, data, name='Vector Layer', **kwargs)</code>","text":"<p>Adds vector data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str, geopandas.GeoDataFrame, or dict</code> <p>The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.</p> required <code>name</code> <code>str</code> <p>Name of the layer to display in the LayerControl. Defaults to \"Vector Layer\".</p> <code>'Vector Layer'</code> <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>maeson/folmap.py</code> <pre><code>def add_vector(self, data, name=\"Vector Layer\", **kwargs):\n    \"\"\"Adds vector data to the map.\n\n    Args:\n        data (str, geopandas.GeoDataFrame, or dict): The vector data. Can be a file path, GeoDataFrame, or GeoJSON dictionary.\n        name (str): Name of the layer to display in the LayerControl. Defaults to \"Vector Layer\".\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        self.add_gdf(gdf, name=name, **kwargs)\n    elif isinstance(data, gpd.GeoDataFrame):\n        self.add_gdf(data, name=name, **kwargs)\n    elif isinstance(data, dict):\n        self.add_geojson(data, name=name, **kwargs)\n    else:\n        raise ValueError(\"Invalid data type\")\n</code></pre>"},{"location":"gistory/","title":"gistory","text":""},{"location":"gistory/#maeson.gistory.Story","title":"<code> Story        </code>","text":"Source code in <code>maeson/gistory.py</code> <pre><code>class Story:\n    def __init__(self, scenes):\n        \"\"\"\n        A sequence of scenes forming a narrative.\n        \"\"\"\n        self.scenes = scenes\n        self.index = 0\n\n    def _current_scene(self):\n        return self.scenes[self.index]\n\n    def _next_scene(self):\n        if self.index &lt; len(self.scenes) - 1:\n            self.index += 1\n        return self._current_scene()\n\n    def _previous_scene(self):\n        if self.index &gt; 0:\n            self.index -= 1\n        return self._current_scene()\n</code></pre>"},{"location":"gistory/#maeson.gistory.Story.__init__","title":"<code>__init__(self, scenes)</code>  <code>special</code>","text":"<p>A sequence of scenes forming a narrative.</p> Source code in <code>maeson/gistory.py</code> <pre><code>def __init__(self, scenes):\n    \"\"\"\n    A sequence of scenes forming a narrative.\n    \"\"\"\n    self.scenes = scenes\n    self.index = 0\n</code></pre>"},{"location":"gistory/#maeson.gistory.StoryController","title":"<code> StoryController        </code>","text":"Source code in <code>maeson/gistory.py</code> <pre><code>class StoryController:\n    def __init__(self, story, map_obj: Map):\n        \"\"\"\n        Connects a Story object to a map and widget-based UI.\n        \"\"\"\n        self.story = story\n        self.map = map_obj\n        self.current_layers = []\n\n        self.next_button = widgets.Button(description=\"Next\")\n        self.back_button = widgets.Button(description=\"Back\")\n        self.next_button.on_click(self._next_scene)\n        self.back_button.on_click(self._previous_scene)\n\n        self.controls = widgets.HBox([self.back_button, self.next_button])\n        self.interface = widgets.VBox([self.map, self.controls])\n\n        self._update_scene()\n\n    def _update_scene(self):\n        scene = self.story._current_scene()\n        # 1) Reset view\n        self.map.center = scene.center\n        self.map.zoom = scene.zoom\n\n        # 2) Clear out any previous overlays\n        self._clear_overlays()\n        self.current_layers.clear()\n\n        # 3) Re\u2011add each layer using your Map methods\n        for ld in scene.layers:\n            t = ld[\"type\"]\n            name = ld.get(\"name\")\n\n            try:\n                if t == \"geojson\":\n                    if \"data\" in ld:\n                        layer = GeoJSON(data=ld[\"data\"], name=name)\n                        self.map.add_layer(layer)\n                    else:\n                        layer = self.map.add_geojson(ld[\"path\"], name=name)\n\n                elif t == \"tile\":\n                    layer = self.map.add_tile(url=ld[\"url\"], name=name)\n\n                elif t == \"image\":\n                    layer = self.map.add_image(\n                        url=ld[\"path\"],\n                        bounds=tuple(tuple(c) for c in ld[\"bounds\"]),\n                        name=name,\n                    )\n\n                elif t == \"video\":\n                    layer = self.map.add_video(\n                        url=ld[\"path\"],\n                        bounds=tuple(tuple(c) for c in ld[\"bounds\"]),\n                        name=name,\n                    )\n\n                elif t == \"raster\":\n                    layer = self.map.add_raster(\n                        ld[\"path\"], name=name, zoom_to_layer=False\n                    )\n\n                elif t == \"wms\":\n                    layer = self.map.add_wms_layer(url=ld[\"url\"], name=name)\n\n                elif t == \"earthengine\":\n                    # your Map.add_earthengine takes ee_object + vis_params\n                    layer = self.map.add_earthengine(\n                        ee_object=ld[\"ee_id\"],\n                        vis_params=ld.get(\"vis_params\", {}),\n                        name=name,\n                    )\n\n                else:\n                    print(f\"Unsupported layer type: {t}\")\n                    continue\n\n                self.current_layers.append(layer)\n\n            except Exception as e:\n                print(f\"\u274c Failed to add {t} layer \u201c{name}\u201d: {e}\")\n\n        # 4) Finally, run any custom code\n        if scene.custom_code.strip():\n            try:\n                exec(scene.custom_code, {}, {\"map\": self.map})\n            except Exception as e:\n                print(f\"\u26a0\ufe0f Error in scene code: {e}\")\n\n    def _clear_overlays(self):\n        # 1) Remove map overlays\n        for lyr in list(self.map.layers)[1:]:\n            self.map.remove_layer(lyr)\n\n    def _next_scene(self, _=None):\n        self.story._next_scene()\n        self._update_scene()\n\n    def _previous_scene(self, _=None):\n        self.story._previous_scene()\n        self._update_scene()\n\n    def display(self):\n        from IPython.display import display\n\n        display(self.interface)\n</code></pre>"},{"location":"gistory/#maeson.gistory.StoryController.__init__","title":"<code>__init__(self, story, map_obj)</code>  <code>special</code>","text":"<p>Connects a Story object to a map and widget-based UI.</p> Source code in <code>maeson/gistory.py</code> <pre><code>def __init__(self, story, map_obj: Map):\n    \"\"\"\n    Connects a Story object to a map and widget-based UI.\n    \"\"\"\n    self.story = story\n    self.map = map_obj\n    self.current_layers = []\n\n    self.next_button = widgets.Button(description=\"Next\")\n    self.back_button = widgets.Button(description=\"Back\")\n    self.next_button.on_click(self._next_scene)\n    self.back_button.on_click(self._previous_scene)\n\n    self.controls = widgets.HBox([self.back_button, self.next_button])\n    self.interface = widgets.VBox([self.map, self.controls])\n\n    self._update_scene()\n</code></pre>"},{"location":"installation/","title":"Installation Guide for MAESON \ud83d\udce6\ud83d\ude80","text":"<p>MAESON is available on PyPI, making it easy to install and use. Follow the steps below to set up MAESON on your system.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites \ud83d\udee0","text":"<p>Before installing MAESON, ensure you have the following: - Python 3.8+ installed on your system. - pip (Python package manager) updated to the latest version - Recommended: A virtual environment (e.g., <code>venv</code> or <code>conda</code>) for package management</p>"},{"location":"installation/#installation-instructions","title":"Installation Instructions \ud83d\udcbe","text":""},{"location":"installation/#1-install-via-pypi","title":"1. Install via PyPI","text":"<p>To install the latest stable release of MAESON, run: <pre><code>pip install maeson\n</code></pre></p>"},{"location":"installation/#2-verify-installation","title":"2. Verify Installation","text":"<p>To check if MAESON was installed successfully, run: <pre><code>import maeson\nprint(maeson.__version__)\n</code></pre> This should return the installed version of MAESON.</p>"},{"location":"installation/#3-optional-install-additional-dependencies","title":"3. Optional: Install Additional Dependencies","text":"<p>If you plan to use advanced features such as deep learning models or high-performance processing, install additional dependencies: <pre><code>pip install maeson[full]\n</code></pre></p>"},{"location":"installation/#upgrading-maeson","title":"Upgrading MAESON \ud83d\udd04","text":"<p>To update MAESON to the latest version, use: <pre><code>pip install --upgrade maeson\n</code></pre></p>"},{"location":"installation/#uninstalling-maeson","title":"Uninstalling MAESON \u274c","text":"<p>If you need to remove MAESON from your system, run: <pre><code>pip uninstall maeson\n</code></pre></p>"},{"location":"installation/#troubleshooting","title":"Troubleshooting \u2753","text":"<p>If you encounter any issues: - Ensure pip and setuptools are up to date:   <pre><code>pip install --upgrade pip setuptools\n</code></pre> - Check for missing dependencies and install them manually. - Report issues on GitHub Issues.</p> <p>\ud83d\ude80 You're now ready to use MAESON! Head over to the User Guide to get started.</p>"},{"location":"maeson/","title":"maeson module","text":"<p>Main module.</p>"},{"location":"maeson/#maeson.maeson.Map","title":"<code> Map            (Map)         </code>","text":"Source code in <code>maeson/maeson.py</code> <pre><code>class Map(Leafmap):\n    def __init__(self, *args, **kwargs):\n        kwargs.setdefault(\"toolbar_control\", True)\n        kwargs.setdefault(\"layer_control\", True)\n        super().__init__(*args, **kwargs)\n\n    def add_basemap(self, basemap=\"Esri.WorldImagery\"):\n        \"\"\"\n        Args:\n            basemap (str): Basemap name. Default is \"Esri.WorldImagery\".\n        \"\"\"\n        \"\"\"Add a basemap to the map.\"\"\"\n        basemaps = [\n            \"OpenStreetMap.Mapnik\",\n            \"Stamen.Terrain\",\n            \"Stamen.TerrainBackground\",\n            \"Stamen.Watercolor\",\n            \"Esri.WorldImagery\",\n            \"Esri.DeLorme\",\n            \"Esri.NatGeoWorldMap\",\n            \"Esri.WorldStreetMap\",\n            \"Esri.WorldTopoMap\",\n            \"Esri.WorldGrayCanvas\",\n            \"Esri.WorldShadedRelief\",\n            \"Esri.WorldPhysical\",\n            \"Esri.WorldTerrain\",\n            \"Google.Satellite\",\n            \"Google.Street\",\n            \"Google.Hybrid\",\n            \"Google.Terrain\",\n        ]\n        url = eval(f\"ipyleaflet.basemaps.{basemap}\").build_url()\n        basemap_layer = ipyleaflet.TileLayer(url=url, name=basemap)\n        self.add(basemap_layer)\n\n    def layer(self, layer) -&gt; None:\n        \"\"\"\n        Args:\n            layer (str or dict): Layer to be added to the map.\n            **kwargs: Additional arguments for the layer.\n        Returns:\n            None\n        Raises:\n            ValueError: If the layer is not a valid type.\n        \"\"\"\n        \"\"\" Convert url to layer\"\"\"\n        if isinstance(layer, str):\n            layer = ipyleaflet.TileLayer(url=layer)\n        elif isinstance(layer, dict):\n            layer = ipyleaflet.GeoJSON(data=layer)\n        elif not isinstance(layer, ipyleaflet.Layer):\n            raise ValueError(\"Layer must be an instance of ipyleaflet.Layer\")\n        return layer\n\n    def add_layer_control(self, position=\"topright\") -&gt; None:\n        \"\"\"Adds a layer control to the map.\n\n        Args:\n            position (str, optional): The position of the layer control. Defaults to 'topright'.\n        \"\"\"\n\n        self.add(ipyleaflet.LayersControl(position=position))\n\n    def add_geojson(self, geojson, **kwargs):\n        \"\"\"\n        Args:\n            geojson (dict): GeoJSON data.\n            **kwargs: Additional arguments for the GeoJSON layer.\n        \"\"\"\n        \"\"\"Add a GeoJSON layer to the map.\"\"\"\n        geojson_layer = ipyleaflet.GeoJSON(data=geojson, **kwargs)\n        self.add(geojson_layer)\n\n    def set_center(self, lat, lon, zoom=6, **kwargs):\n        \"\"\"\n        Args:\n            lat (float): Latitude of the center.\n            lon (float): Longitude of the center.\n            zoom (int): Zoom level.\n            **kwargs: Additional arguments for the map.\n        \"\"\"\n        \"\"\"Set the center of the map.\"\"\"\n        self.center = (lat, lon)\n        self.zoom = zoom\n\n    def center_object(self, obj, zoom=6, **kwargs):\n        \"\"\"\n        Args:\n            obj (str or dict): Object to center the map on.\n            zoom (int): Zoom level.\n            **kwargs: Additional arguments for the map.\n        \"\"\"\n        \"\"\"Center the map on an object.\"\"\"\n        if isinstance(obj, str):\n            obj = ipyleaflet.GeoJSON(data=obj, **kwargs)\n        elif not isinstance(obj, ipyleaflet.Layer):\n            raise ValueError(\"Object must be an instance of ipyleaflet.Layer\")\n        self.center = (obj.location[0], obj.location[1])\n        self.zoom = zoom\n\n    def add_vector(self, vector, **kwargs):\n        \"\"\"\n        Args:\n            vector (dict): Vector data.\n            **kwargs: Additional arguments for the GeoJSON layer.\n        \"\"\"\n        \"\"\"Add a vector layer to the map from Geopandas.\"\"\"\n        vector_layer = ipyleaflet.GeoJSON(data=vector, **kwargs)\n        self.add(vector_layer)\n\n    def add_raster(\n        self,\n        filepath: str,\n        name: str = None,\n        colormap=\"greys\",\n        opacity: float = 1.0,\n        zoom_to_layer: bool = True,\n        **kwargs,\n    ):\n        \"\"\"\n        Add a raster (COG) layer to the map and return it.\n\n        Parameters\n        ----------\n        filepath : str\n            URL or local path to a Cloud\u2011Optimized GeoTIFF.\n        name : str, optional\n            Display name for the layer. Defaults to filename.\n        colormap : dict or str, optional\n            A colormap dictionary or registered name (e.g. \"viridis\").\n        opacity : float, optional\n            0.0 (transparent) \u2013 1.0 (opaque).\n        zoom_to_layer : bool, optional\n            If True, fit the map to the raster\u2019s bounds after adding.\n        **kwargs : dict\n            Extra kwargs passed to `get_leaflet_tile_layer`.\n\n        Returns\n        -------\n        ipyleaflet.Layer\n            The tile layer that was added.\n        \"\"\"\n        # 1) If it\u2019s a GitHub \u201crelease/download\u201d URL, pull it down locally\n        if (\n            filepath.startswith(\"https://github.com/\")\n            and \"/releases/download/\" in filepath\n        ):\n            fname = os.path.basename(filepath)\n            tmp_dir = tempfile.gettempdir()\n            local_fp = os.path.join(tmp_dir, fname)\n            if not os.path.exists(local_fp):\n                resp = requests.get(filepath, stream=True)\n                resp.raise_for_status()\n                with open(local_fp, \"wb\") as f:\n                    for chunk in resp.iter_content(1024 * 1024):\n                        f.write(chunk)\n            filepath = local_fp\n\n        # 2) Inspect with rasterio: get colormap if needed + bounds\n        with rasterio.open(filepath) as src:\n            if colormap is None:\n                try:\n                    colormap = src.colormap(1)\n                except Exception:\n                    colormap = \"greys\"\n            left, bottom, right, top = src.bounds\n\n        # 3) Spin up the tile server + leaflet layer\n        client = TileClient(filepath)\n        layer_name = name or os.path.basename(filepath)\n        tile_layer = get_leaflet_tile_layer(\n            client, name=layer_name, colormap=colormap, opacity=opacity, **kwargs\n        )\n\n        # 4) Add to the map\n        try:\n            self.add_layer(tile_layer)\n        except AttributeError:\n            # fallback if your class uses .add() instead\n            self.add(tile_layer)\n\n        # 5) Ensure it has a valid name\n        if hasattr(tile_layer, \"name\") and not tile_layer.name:\n            tile_layer.name = layer_name\n\n        # 6) Auto\u2011zoom if requested\n        if zoom_to_layer:\n            sw = (bottom, left)\n            ne = (top, right)\n            try:\n                self.fit_bounds([sw, ne])\n            except Exception:\n                # if you're using leafmap you could also call:\n                # self.zoom_to_layer(tile_layer)\n                pass\n\n        return tile_layer\n\n    def add_image(self, url, bounds, opacity=1, **kwargs):\n        \"\"\"\n        Adds an image or animated GIF overlay to the map.\n\n        Parameters:\n            url (str): The URL of the image or GIF.\n            bounds (tuple): Geographic coordinates as ((south, west), (north, east)).\n            opacity (float, optional): The transparency level of the overlay (default is 1, fully opaque).\n            **kwargs: Additional keyword arguments for ipyleaflet.ImageOverlay.\n\n        Raises:\n            ValueError: If bounds is not provided or is improperly formatted.\n        \"\"\"\n\n        # Validate bounds: It should be a tuple of two coordinate tuples, each of length 2.\n        if not (\n            isinstance(bounds, tuple)\n            and len(bounds) == 2\n            and all(isinstance(coord, tuple) and len(coord) == 2 for coord in bounds)\n        ):\n            raise ValueError(\n                \"bounds must be a tuple in the format ((south, west), (north, east))\"\n            )\n\n        # Create the image overlay using ipyleaflet.ImageOverlay.\n        overlay = ipyleaflet.ImageOverlay(\n            url=url, bounds=bounds, opacity=opacity, **kwargs\n        )\n\n        # Add the overlay to the map.\n        self.add(overlay)\n        self.center = [\n            (bounds[0][0] + bounds[1][0]) / 2,\n            (bounds[0][1] + bounds[1][1]) / 2,\n        ]\n\n    def add_video(\n        self,\n        url: str,\n        bounds,\n        opacity: float = 1.0,\n        autoplay: bool = True,\n        loop: bool = True,\n        muted: bool = True,\n        **kwargs,\n    ):\n        \"\"\"\n        Adds a video overlay to the map using ipyleaflet.VideoOverlay.\n        \"\"\"\n        # 1) Validate &amp; normalize bounds\n        if not (\n            isinstance(bounds, (tuple, list))\n            and len(bounds) == 2\n            and all(isinstance(c, (tuple, list)) and len(c) == 2 for c in bounds)\n        ):\n            raise ValueError(\"bounds must be ((south, west), (north, east))\")\n\n        bounds = [list(bounds[0]), list(bounds[1])]\n\n        # 2) Create the VideoOverlay (url must be a string)\n        overlay = VideoOverlay(\n            url=url,\n            bounds=bounds,\n            opacity=opacity,\n            autoplay=autoplay,\n            loop=loop,\n            muted=muted,\n            **kwargs,\n        )\n\n        # 3) Add to map and fit to the bounds\n        self.add_layer(overlay)  # or self.map.add_layer if you wrap it\n        self.fit_bounds(bounds)\n\n    def add_wms_layer(self, url, layers, name, format, transparent, **kwargs):\n        \"\"\"\n        Adds a WMS (Web Map Service) layer to the map using ipyleaflet.WMSLayer.\n\n        Parameters:\n            url (str): Base WMS endpoint.\n            layers (str): Comma-separated layer names.\n            name (str): Display name for the layer.\n            format (str): Image format (e.g., 'image/png').\n            transparent (bool): Whether the WMS layer should be transparent.\n            **kwargs: Additional keyword arguments for ipyleaflet.WMSLayer.\n        \"\"\"\n\n        # Create the WMS layer using the provided parameters.\n        wms_layer = WMSLayer(\n            url=url,\n            layers=layers,\n            name=name,\n            format=format,\n            transparent=transparent,\n            **kwargs,\n        )\n\n        # Add the WMS layer to the map.\n        self.add(wms_layer)\n\n    def add_basemap_dropdown(self):\n        \"\"\"\n        Adds a dropdown + hide button as a map control.\n        Keeps track of the current basemap layer so that selecting\n        a new one removes the old and adds the new immediately.\n\n        Returns:\n            None\n        \"\"\"\n        # 1. define your choices\n        basemap_dict = {\n            \"OpenStreetMap\": basemaps.OpenStreetMap.Mapnik,\n            \"OpenTopoMap\": basemaps.OpenTopoMap,\n            \"Esri.WorldImagery\": basemaps.Esri.WorldImagery,\n            \"CartoDB.DarkMatter\": basemaps.CartoDB.DarkMatter,\n        }\n\n        # 2. build widgets\n        dropdown = widgets.Dropdown(\n            options=list(basemap_dict.keys()),\n            value=\"OpenStreetMap\",\n            layout={\"width\": \"180px\"},\n            description=\"Basemap:\",\n        )\n        hide_btn = widgets.Button(description=\"Hide\", button_style=\"danger\")\n        container = widgets.VBox([dropdown, hide_btn])\n\n        # 3. add the initial basemap layer and remember it\n        initial = basemap_dict[dropdown.value]\n        self._current_basemap = basemap_to_tiles(initial)\n        self.add_layer(self._current_basemap)\n\n        # 4. when user picks a new basemap, swap layers\n        def _on_change(change):\n            if change[\"name\"] == \"value\":\n                new_tiles = basemap_to_tiles(basemap_dict[change[\"new\"]])\n                # remove old\n                self.remove_layer(self._current_basemap)\n                # add new &amp; store reference\n                self._current_basemap = new_tiles\n                self.add_layer(self._current_basemap)\n\n        dropdown.observe(_on_change, names=\"value\")\n\n        # 5. hide control if needed\n        hide_btn.on_click(lambda _: setattr(container.layout, \"display\", \"none\"))\n\n        # 6. wrap in a WidgetControl and add to map\n        ctrl = WidgetControl(widget=container, position=\"topright\")\n        self.add_control(ctrl)\n\n    def add_earthengine(self, ee_object, vis_params=None, name=\"EE Layer\"):\n        \"\"\"\n        Adds an Earth Engine layer to the map.\n\n        Parameters\n        ----------\n        ee_object : ee.Image, ee.ImageCollection, or str\n            If str, will be wrapped as ee.Image; for ImageCollection,\n            you should reduce it (e.g. .mean()) before passing.\n        vis_params : dict, optional\n            Visualization parameters, e.g. {\"min\":0,\"max\":3000,\"palette\":[\"blue\",\"red\"]}.\n        name : str, optional\n            A display name for the layer.\n        \"\"\"\n        # 1) Initialize EE if needed\n        try:\n            ee.Initialize()\n        except Exception:\n            ee.Authenticate()\n            ee.Initialize()\n\n        # 2) Wrap strings into Images\n        if isinstance(ee_object, str):\n            ee_object = ee.Image(ee_object)\n\n        # 3) Build the TileLayer via geemap helper\n        vis_params = vis_params or {}\n        tile_layer = geemap.ee_tile_layer(ee_object, vis_params, name)\n\n        # 4) Add to the map\n        self.add_layer(tile_layer)\n\n        # 5) Optionally fit bounds (EE layers often global)\n        # comment this out if you don\u2019t want auto\u2011zoom\n        try:\n            bounds = ee_object.geometry().bounds().getInfo()[\"coordinates\"][0]\n            # bounds is [[lon, lat], \u2026], ipyleaflet wants [[lat, lon], \u2026]\n            latlng_bounds = [[lat, lon] for lon, lat in bounds]\n            self.fit_bounds(latlng_bounds)\n        except Exception:\n            pass\n\n        return tile_layer\n</code></pre>"},{"location":"maeson/#maeson.maeson.Map.add_basemap","title":"<code>add_basemap(self, basemap='Esri.WorldImagery')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Basemap name. Default is \"Esri.WorldImagery\".</p> <code>'Esri.WorldImagery'</code> Source code in <code>maeson/maeson.py</code> <pre><code>def add_basemap(self, basemap=\"Esri.WorldImagery\"):\n    \"\"\"\n    Args:\n        basemap (str): Basemap name. Default is \"Esri.WorldImagery\".\n    \"\"\"\n    \"\"\"Add a basemap to the map.\"\"\"\n    basemaps = [\n        \"OpenStreetMap.Mapnik\",\n        \"Stamen.Terrain\",\n        \"Stamen.TerrainBackground\",\n        \"Stamen.Watercolor\",\n        \"Esri.WorldImagery\",\n        \"Esri.DeLorme\",\n        \"Esri.NatGeoWorldMap\",\n        \"Esri.WorldStreetMap\",\n        \"Esri.WorldTopoMap\",\n        \"Esri.WorldGrayCanvas\",\n        \"Esri.WorldShadedRelief\",\n        \"Esri.WorldPhysical\",\n        \"Esri.WorldTerrain\",\n        \"Google.Satellite\",\n        \"Google.Street\",\n        \"Google.Hybrid\",\n        \"Google.Terrain\",\n    ]\n    url = eval(f\"ipyleaflet.basemaps.{basemap}\").build_url()\n    basemap_layer = ipyleaflet.TileLayer(url=url, name=basemap)\n    self.add(basemap_layer)\n</code></pre>"},{"location":"maeson/#maeson.maeson.Map.add_basemap_dropdown","title":"<code>add_basemap_dropdown(self)</code>","text":"<p>Adds a dropdown + hide button as a map control. Keeps track of the current basemap layer so that selecting a new one removes the old and adds the new immediately.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>maeson/maeson.py</code> <pre><code>def add_basemap_dropdown(self):\n    \"\"\"\n    Adds a dropdown + hide button as a map control.\n    Keeps track of the current basemap layer so that selecting\n    a new one removes the old and adds the new immediately.\n\n    Returns:\n        None\n    \"\"\"\n    # 1. define your choices\n    basemap_dict = {\n        \"OpenStreetMap\": basemaps.OpenStreetMap.Mapnik,\n        \"OpenTopoMap\": basemaps.OpenTopoMap,\n        \"Esri.WorldImagery\": basemaps.Esri.WorldImagery,\n        \"CartoDB.DarkMatter\": basemaps.CartoDB.DarkMatter,\n    }\n\n    # 2. build widgets\n    dropdown = widgets.Dropdown(\n        options=list(basemap_dict.keys()),\n        value=\"OpenStreetMap\",\n        layout={\"width\": \"180px\"},\n        description=\"Basemap:\",\n    )\n    hide_btn = widgets.Button(description=\"Hide\", button_style=\"danger\")\n    container = widgets.VBox([dropdown, hide_btn])\n\n    # 3. add the initial basemap layer and remember it\n    initial = basemap_dict[dropdown.value]\n    self._current_basemap = basemap_to_tiles(initial)\n    self.add_layer(self._current_basemap)\n\n    # 4. when user picks a new basemap, swap layers\n    def _on_change(change):\n        if change[\"name\"] == \"value\":\n            new_tiles = basemap_to_tiles(basemap_dict[change[\"new\"]])\n            # remove old\n            self.remove_layer(self._current_basemap)\n            # add new &amp; store reference\n            self._current_basemap = new_tiles\n            self.add_layer(self._current_basemap)\n\n    dropdown.observe(_on_change, names=\"value\")\n\n    # 5. hide control if needed\n    hide_btn.on_click(lambda _: setattr(container.layout, \"display\", \"none\"))\n\n    # 6. wrap in a WidgetControl and add to map\n    ctrl = WidgetControl(widget=container, position=\"topright\")\n    self.add_control(ctrl)\n</code></pre>"},{"location":"maeson/#maeson.maeson.Map.add_earthengine","title":"<code>add_earthengine(self, ee_object, vis_params=None, name='EE Layer')</code>","text":"<p>Adds an Earth Engine layer to the map.</p>"},{"location":"maeson/#maeson.maeson.Map.add_earthengine--parameters","title":"Parameters","text":"<p>ee_object : ee.Image, ee.ImageCollection, or str     If str, will be wrapped as ee.Image; for ImageCollection,     you should reduce it (e.g. .mean()) before passing. vis_params : dict, optional     Visualization parameters, e.g. {\"min\":0,\"max\":3000,\"palette\":[\"blue\",\"red\"]}. name : str, optional     A display name for the layer.</p> Source code in <code>maeson/maeson.py</code> <pre><code>def add_earthengine(self, ee_object, vis_params=None, name=\"EE Layer\"):\n    \"\"\"\n    Adds an Earth Engine layer to the map.\n\n    Parameters\n    ----------\n    ee_object : ee.Image, ee.ImageCollection, or str\n        If str, will be wrapped as ee.Image; for ImageCollection,\n        you should reduce it (e.g. .mean()) before passing.\n    vis_params : dict, optional\n        Visualization parameters, e.g. {\"min\":0,\"max\":3000,\"palette\":[\"blue\",\"red\"]}.\n    name : str, optional\n        A display name for the layer.\n    \"\"\"\n    # 1) Initialize EE if needed\n    try:\n        ee.Initialize()\n    except Exception:\n        ee.Authenticate()\n        ee.Initialize()\n\n    # 2) Wrap strings into Images\n    if isinstance(ee_object, str):\n        ee_object = ee.Image(ee_object)\n\n    # 3) Build the TileLayer via geemap helper\n    vis_params = vis_params or {}\n    tile_layer = geemap.ee_tile_layer(ee_object, vis_params, name)\n\n    # 4) Add to the map\n    self.add_layer(tile_layer)\n\n    # 5) Optionally fit bounds (EE layers often global)\n    # comment this out if you don\u2019t want auto\u2011zoom\n    try:\n        bounds = ee_object.geometry().bounds().getInfo()[\"coordinates\"][0]\n        # bounds is [[lon, lat], \u2026], ipyleaflet wants [[lat, lon], \u2026]\n        latlng_bounds = [[lat, lon] for lon, lat in bounds]\n        self.fit_bounds(latlng_bounds)\n    except Exception:\n        pass\n\n    return tile_layer\n</code></pre>"},{"location":"maeson/#maeson.maeson.Map.add_geojson","title":"<code>add_geojson(self, geojson, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>geojson</code> <code>dict</code> <p>GeoJSON data.</p> required <code>**kwargs</code> <p>Additional arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>maeson/maeson.py</code> <pre><code>def add_geojson(self, geojson, **kwargs):\n    \"\"\"\n    Args:\n        geojson (dict): GeoJSON data.\n        **kwargs: Additional arguments for the GeoJSON layer.\n    \"\"\"\n    \"\"\"Add a GeoJSON layer to the map.\"\"\"\n    geojson_layer = ipyleaflet.GeoJSON(data=geojson, **kwargs)\n    self.add(geojson_layer)\n</code></pre>"},{"location":"maeson/#maeson.maeson.Map.add_image","title":"<code>add_image(self, url, bounds, opacity=1, **kwargs)</code>","text":"<p>Adds an image or animated GIF overlay to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the image or GIF.</p> required <code>bounds</code> <code>tuple</code> <p>Geographic coordinates as ((south, west), (north, east)).</p> required <code>opacity</code> <code>float</code> <p>The transparency level of the overlay (default is 1, fully opaque).</p> <code>1</code> <code>**kwargs</code> <p>Additional keyword arguments for ipyleaflet.ImageOverlay.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If bounds is not provided or is improperly formatted.</p> Source code in <code>maeson/maeson.py</code> <pre><code>def add_image(self, url, bounds, opacity=1, **kwargs):\n    \"\"\"\n    Adds an image or animated GIF overlay to the map.\n\n    Parameters:\n        url (str): The URL of the image or GIF.\n        bounds (tuple): Geographic coordinates as ((south, west), (north, east)).\n        opacity (float, optional): The transparency level of the overlay (default is 1, fully opaque).\n        **kwargs: Additional keyword arguments for ipyleaflet.ImageOverlay.\n\n    Raises:\n        ValueError: If bounds is not provided or is improperly formatted.\n    \"\"\"\n\n    # Validate bounds: It should be a tuple of two coordinate tuples, each of length 2.\n    if not (\n        isinstance(bounds, tuple)\n        and len(bounds) == 2\n        and all(isinstance(coord, tuple) and len(coord) == 2 for coord in bounds)\n    ):\n        raise ValueError(\n            \"bounds must be a tuple in the format ((south, west), (north, east))\"\n        )\n\n    # Create the image overlay using ipyleaflet.ImageOverlay.\n    overlay = ipyleaflet.ImageOverlay(\n        url=url, bounds=bounds, opacity=opacity, **kwargs\n    )\n\n    # Add the overlay to the map.\n    self.add(overlay)\n    self.center = [\n        (bounds[0][0] + bounds[1][0]) / 2,\n        (bounds[0][1] + bounds[1][1]) / 2,\n    ]\n</code></pre>"},{"location":"maeson/#maeson.maeson.Map.add_layer_control","title":"<code>add_layer_control(self, position='topright')</code>","text":"<p>Adds a layer control to the map.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>The position of the layer control. Defaults to 'topright'.</p> <code>'topright'</code> Source code in <code>maeson/maeson.py</code> <pre><code>def add_layer_control(self, position=\"topright\") -&gt; None:\n    \"\"\"Adds a layer control to the map.\n\n    Args:\n        position (str, optional): The position of the layer control. Defaults to 'topright'.\n    \"\"\"\n\n    self.add(ipyleaflet.LayersControl(position=position))\n</code></pre>"},{"location":"maeson/#maeson.maeson.Map.add_raster","title":"<code>add_raster(self, filepath, name=None, colormap='greys', opacity=1.0, zoom_to_layer=True, **kwargs)</code>","text":"<p>Add a raster (COG) layer to the map and return it.</p>"},{"location":"maeson/#maeson.maeson.Map.add_raster--parameters","title":"Parameters","text":"<p>filepath : str     URL or local path to a Cloud\u2011Optimized GeoTIFF. name : str, optional     Display name for the layer. Defaults to filename. colormap : dict or str, optional     A colormap dictionary or registered name (e.g. \"viridis\"). opacity : float, optional     0.0 (transparent) \u2013 1.0 (opaque). zoom_to_layer : bool, optional     If True, fit the map to the raster\u2019s bounds after adding. **kwargs : dict     Extra kwargs passed to <code>get_leaflet_tile_layer</code>.</p>"},{"location":"maeson/#maeson.maeson.Map.add_raster--returns","title":"Returns","text":"<p>ipyleaflet.Layer     The tile layer that was added.</p> Source code in <code>maeson/maeson.py</code> <pre><code>def add_raster(\n    self,\n    filepath: str,\n    name: str = None,\n    colormap=\"greys\",\n    opacity: float = 1.0,\n    zoom_to_layer: bool = True,\n    **kwargs,\n):\n    \"\"\"\n    Add a raster (COG) layer to the map and return it.\n\n    Parameters\n    ----------\n    filepath : str\n        URL or local path to a Cloud\u2011Optimized GeoTIFF.\n    name : str, optional\n        Display name for the layer. Defaults to filename.\n    colormap : dict or str, optional\n        A colormap dictionary or registered name (e.g. \"viridis\").\n    opacity : float, optional\n        0.0 (transparent) \u2013 1.0 (opaque).\n    zoom_to_layer : bool, optional\n        If True, fit the map to the raster\u2019s bounds after adding.\n    **kwargs : dict\n        Extra kwargs passed to `get_leaflet_tile_layer`.\n\n    Returns\n    -------\n    ipyleaflet.Layer\n        The tile layer that was added.\n    \"\"\"\n    # 1) If it\u2019s a GitHub \u201crelease/download\u201d URL, pull it down locally\n    if (\n        filepath.startswith(\"https://github.com/\")\n        and \"/releases/download/\" in filepath\n    ):\n        fname = os.path.basename(filepath)\n        tmp_dir = tempfile.gettempdir()\n        local_fp = os.path.join(tmp_dir, fname)\n        if not os.path.exists(local_fp):\n            resp = requests.get(filepath, stream=True)\n            resp.raise_for_status()\n            with open(local_fp, \"wb\") as f:\n                for chunk in resp.iter_content(1024 * 1024):\n                    f.write(chunk)\n        filepath = local_fp\n\n    # 2) Inspect with rasterio: get colormap if needed + bounds\n    with rasterio.open(filepath) as src:\n        if colormap is None:\n            try:\n                colormap = src.colormap(1)\n            except Exception:\n                colormap = \"greys\"\n        left, bottom, right, top = src.bounds\n\n    # 3) Spin up the tile server + leaflet layer\n    client = TileClient(filepath)\n    layer_name = name or os.path.basename(filepath)\n    tile_layer = get_leaflet_tile_layer(\n        client, name=layer_name, colormap=colormap, opacity=opacity, **kwargs\n    )\n\n    # 4) Add to the map\n    try:\n        self.add_layer(tile_layer)\n    except AttributeError:\n        # fallback if your class uses .add() instead\n        self.add(tile_layer)\n\n    # 5) Ensure it has a valid name\n    if hasattr(tile_layer, \"name\") and not tile_layer.name:\n        tile_layer.name = layer_name\n\n    # 6) Auto\u2011zoom if requested\n    if zoom_to_layer:\n        sw = (bottom, left)\n        ne = (top, right)\n        try:\n            self.fit_bounds([sw, ne])\n        except Exception:\n            # if you're using leafmap you could also call:\n            # self.zoom_to_layer(tile_layer)\n            pass\n\n    return tile_layer\n</code></pre>"},{"location":"maeson/#maeson.maeson.Map.add_vector","title":"<code>add_vector(self, vector, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>vector</code> <code>dict</code> <p>Vector data.</p> required <code>**kwargs</code> <p>Additional arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>maeson/maeson.py</code> <pre><code>def add_vector(self, vector, **kwargs):\n    \"\"\"\n    Args:\n        vector (dict): Vector data.\n        **kwargs: Additional arguments for the GeoJSON layer.\n    \"\"\"\n    \"\"\"Add a vector layer to the map from Geopandas.\"\"\"\n    vector_layer = ipyleaflet.GeoJSON(data=vector, **kwargs)\n    self.add(vector_layer)\n</code></pre>"},{"location":"maeson/#maeson.maeson.Map.add_video","title":"<code>add_video(self, url, bounds, opacity=1.0, autoplay=True, loop=True, muted=True, **kwargs)</code>","text":"<p>Adds a video overlay to the map using ipyleaflet.VideoOverlay.</p> Source code in <code>maeson/maeson.py</code> <pre><code>def add_video(\n    self,\n    url: str,\n    bounds,\n    opacity: float = 1.0,\n    autoplay: bool = True,\n    loop: bool = True,\n    muted: bool = True,\n    **kwargs,\n):\n    \"\"\"\n    Adds a video overlay to the map using ipyleaflet.VideoOverlay.\n    \"\"\"\n    # 1) Validate &amp; normalize bounds\n    if not (\n        isinstance(bounds, (tuple, list))\n        and len(bounds) == 2\n        and all(isinstance(c, (tuple, list)) and len(c) == 2 for c in bounds)\n    ):\n        raise ValueError(\"bounds must be ((south, west), (north, east))\")\n\n    bounds = [list(bounds[0]), list(bounds[1])]\n\n    # 2) Create the VideoOverlay (url must be a string)\n    overlay = VideoOverlay(\n        url=url,\n        bounds=bounds,\n        opacity=opacity,\n        autoplay=autoplay,\n        loop=loop,\n        muted=muted,\n        **kwargs,\n    )\n\n    # 3) Add to map and fit to the bounds\n    self.add_layer(overlay)  # or self.map.add_layer if you wrap it\n    self.fit_bounds(bounds)\n</code></pre>"},{"location":"maeson/#maeson.maeson.Map.add_wms_layer","title":"<code>add_wms_layer(self, url, layers, name, format, transparent, **kwargs)</code>","text":"<p>Adds a WMS (Web Map Service) layer to the map using ipyleaflet.WMSLayer.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Base WMS endpoint.</p> required <code>layers</code> <code>str</code> <p>Comma-separated layer names.</p> required <code>name</code> <code>str</code> <p>Display name for the layer.</p> required <code>format</code> <code>str</code> <p>Image format (e.g., 'image/png').</p> required <code>transparent</code> <code>bool</code> <p>Whether the WMS layer should be transparent.</p> required <code>**kwargs</code> <p>Additional keyword arguments for ipyleaflet.WMSLayer.</p> <code>{}</code> Source code in <code>maeson/maeson.py</code> <pre><code>def add_wms_layer(self, url, layers, name, format, transparent, **kwargs):\n    \"\"\"\n    Adds a WMS (Web Map Service) layer to the map using ipyleaflet.WMSLayer.\n\n    Parameters:\n        url (str): Base WMS endpoint.\n        layers (str): Comma-separated layer names.\n        name (str): Display name for the layer.\n        format (str): Image format (e.g., 'image/png').\n        transparent (bool): Whether the WMS layer should be transparent.\n        **kwargs: Additional keyword arguments for ipyleaflet.WMSLayer.\n    \"\"\"\n\n    # Create the WMS layer using the provided parameters.\n    wms_layer = WMSLayer(\n        url=url,\n        layers=layers,\n        name=name,\n        format=format,\n        transparent=transparent,\n        **kwargs,\n    )\n\n    # Add the WMS layer to the map.\n    self.add(wms_layer)\n</code></pre>"},{"location":"maeson/#maeson.maeson.Map.center_object","title":"<code>center_object(self, obj, zoom=6, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>obj</code> <code>str or dict</code> <p>Object to center the map on.</p> required <code>zoom</code> <code>int</code> <p>Zoom level.</p> <code>6</code> <code>**kwargs</code> <p>Additional arguments for the map.</p> <code>{}</code> Source code in <code>maeson/maeson.py</code> <pre><code>def center_object(self, obj, zoom=6, **kwargs):\n    \"\"\"\n    Args:\n        obj (str or dict): Object to center the map on.\n        zoom (int): Zoom level.\n        **kwargs: Additional arguments for the map.\n    \"\"\"\n    \"\"\"Center the map on an object.\"\"\"\n    if isinstance(obj, str):\n        obj = ipyleaflet.GeoJSON(data=obj, **kwargs)\n    elif not isinstance(obj, ipyleaflet.Layer):\n        raise ValueError(\"Object must be an instance of ipyleaflet.Layer\")\n    self.center = (obj.location[0], obj.location[1])\n    self.zoom = zoom\n</code></pre>"},{"location":"maeson/#maeson.maeson.Map.layer","title":"<code>layer(self, layer)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>layer</code> <code>str or dict</code> <p>Layer to be added to the map.</p> required <code>**kwargs</code> <p>Additional arguments for the layer.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the layer is not a valid type.</p> Source code in <code>maeson/maeson.py</code> <pre><code>def layer(self, layer) -&gt; None:\n    \"\"\"\n    Args:\n        layer (str or dict): Layer to be added to the map.\n        **kwargs: Additional arguments for the layer.\n    Returns:\n        None\n    Raises:\n        ValueError: If the layer is not a valid type.\n    \"\"\"\n    \"\"\" Convert url to layer\"\"\"\n    if isinstance(layer, str):\n        layer = ipyleaflet.TileLayer(url=layer)\n    elif isinstance(layer, dict):\n        layer = ipyleaflet.GeoJSON(data=layer)\n    elif not isinstance(layer, ipyleaflet.Layer):\n        raise ValueError(\"Layer must be an instance of ipyleaflet.Layer\")\n    return layer\n</code></pre>"},{"location":"maeson/#maeson.maeson.Map.set_center","title":"<code>set_center(self, lat, lon, zoom=6, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>lat</code> <code>float</code> <p>Latitude of the center.</p> required <code>lon</code> <code>float</code> <p>Longitude of the center.</p> required <code>zoom</code> <code>int</code> <p>Zoom level.</p> <code>6</code> <code>**kwargs</code> <p>Additional arguments for the map.</p> <code>{}</code> Source code in <code>maeson/maeson.py</code> <pre><code>def set_center(self, lat, lon, zoom=6, **kwargs):\n    \"\"\"\n    Args:\n        lat (float): Latitude of the center.\n        lon (float): Longitude of the center.\n        zoom (int): Zoom level.\n        **kwargs: Additional arguments for the map.\n    \"\"\"\n    \"\"\"Set the center of the map.\"\"\"\n    self.center = (lat, lon)\n    self.zoom = zoom\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use maeson in a project:</p> <pre><code>import maeson\n</code></pre>"},{"location":"examples/usage/","title":"Usage","text":"In\u00a0[1]: Copied! <pre>import maeson as maeson\n</pre> import maeson as maeson In\u00a0[2]: Copied! <pre>json = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"properties\": {},\n            \"geometry\": {\n                \"coordinates\": [\n                    [\n                        [-0.23448112880515737, 5.569309741857438],\n                        [-0.23448112880515737, 5.536174574314842],\n                        [-0.19047541529968726, 5.536174574314842],\n                        [-0.19047541529968726, 5.569309741857438],\n                        [-0.23448112880515737, 5.569309741857438],\n                    ]\n                ],\n                \"type\": \"Polygon\",\n            },\n        }\n    ],\n}\n</pre> json = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"properties\": {},             \"geometry\": {                 \"coordinates\": [                     [                         [-0.23448112880515737, 5.569309741857438],                         [-0.23448112880515737, 5.536174574314842],                         [-0.19047541529968726, 5.536174574314842],                         [-0.19047541529968726, 5.569309741857438],                         [-0.23448112880515737, 5.569309741857438],                     ]                 ],                 \"type\": \"Polygon\",             },         }     ], } In\u00a0[3]: Copied! <pre># Create map\nm = maeson.Map(zoom=12, center=(5.55, -0.2))\n\n# Add GeoJSON Layer\nm.add_geojson(json, name=\"GeoJSON Layer\", style={\"color\": \"blue\", \"weight\": 2})\n\nm\n</pre> # Create map m = maeson.Map(zoom=12, center=(5.55, -0.2))  # Add GeoJSON Layer m.add_geojson(json, name=\"GeoJSON Layer\", style={\"color\": \"blue\", \"weight\": 2})  m Out[3]: In\u00a0[4]: Copied! <pre>url = \"https://github.com/opengeos/datasets/releases/download/samgeo/tree_image.tif\"\n\nrmap = maeson.Map(zoom=12, center=(5.55, -0.2))\n\n# Add GeoJSON Layer\nrmap.add_raster(filepath=url, name=\"Trees\", colormap=\"viridis\", opacity=0.8)\n\nrmap\n</pre> url = \"https://github.com/opengeos/datasets/releases/download/samgeo/tree_image.tif\"  rmap = maeson.Map(zoom=12, center=(5.55, -0.2))  # Add GeoJSON Layer rmap.add_raster(filepath=url, name=\"Trees\", colormap=\"viridis\", opacity=0.8)  rmap Out[4]: In\u00a0[5]: Copied! <pre>url = \"https://i.imgur.com/06Q1fSz.png\"\nimap = maeson.Map(zoom=4)\n\n# Add Image Layer\nimap.add_image(url, name=\"Image\", bounds=((13, -130), (32, -100)), opacity=0.5)\n\nimap\n</pre> url = \"https://i.imgur.com/06Q1fSz.png\" imap = maeson.Map(zoom=4)  # Add Image Layer imap.add_image(url, name=\"Image\", bounds=((13, -130), (32, -100)), opacity=0.5)  imap Out[5]: In\u00a0[6]: Copied! <pre>import maeson\n\ntest_url = \"https://media.w3.org/2010/05/sintel/trailer.mp4\"\n\nvmap = maeson.Map(zoom=4)\n\n# Add Video Layer\nvmap.add_video(test_url, bounds=[[37.75, -122.5], [37.8, -122.35]])\nvmap\n</pre> import maeson  test_url = \"https://media.w3.org/2010/05/sintel/trailer.mp4\"  vmap = maeson.Map(zoom=4)  # Add Video Layer vmap.add_video(test_url, bounds=[[37.75, -122.5], [37.8, -122.35]]) vmap Out[6]: In\u00a0[7]: Copied! <pre>url = \"http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi\"\n\nwms = maeson.Map(zoom=4, center=(39.5, -98.35))\n\n# Add WMS Layer\nwms.add_wms_layer(\n    url,\n    name=\"WMS Layer\",\n    layers=\"nexrad-n0r-900913\",\n    format=\"image/png\",\n    transparent=True,\n)\nwms\n</pre> url = \"http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi\"  wms = maeson.Map(zoom=4, center=(39.5, -98.35))  # Add WMS Layer wms.add_wms_layer(     url,     name=\"WMS Layer\",     layers=\"nexrad-n0r-900913\",     format=\"image/png\",     transparent=True, ) wms Out[7]: In\u00a0[8]: Copied! <pre>wid = maeson.Map()\n\nwid.add_basemap_dropdown()\n\nwid\n</pre> wid = maeson.Map()  wid.add_basemap_dropdown()  wid Out[8]: In\u00a0[9]: Copied! <pre>from maeson import folmap\n\n# Create map\nm = folmap.Map(zoom=12, center=(5.55, -0.2))\n\n# # Choose a built-in basemap\n# m.add_basemap(name='Topo')\n# m.add_basemap(name='Terrain')\nm.add_basemap(name=\"Satellite\")\n# m.add_basemap(name='Road')\n\n# # Add layer control\nm.add_layer_control()\n\nm\n</pre> from maeson import folmap  # Create map m = folmap.Map(zoom=12, center=(5.55, -0.2))  # # Choose a built-in basemap # m.add_basemap(name='Topo') # m.add_basemap(name='Terrain') m.add_basemap(name=\"Satellite\") # m.add_basemap(name='Road')  # # Add layer control m.add_layer_control()  m Out[9]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[10]: Copied! <pre>map = folmap.Map(zoom=12, center=(5.55, -0.2))\n\n# Add JSON Layer\nmap.add_geojson(json, name=\"GeoJSON Layer\", style={\"color\": \"blue\", \"weight\": 2})\nmap\n</pre> map = folmap.Map(zoom=12, center=(5.55, -0.2))  # Add JSON Layer map.add_geojson(json, name=\"GeoJSON Layer\", style={\"color\": \"blue\", \"weight\": 2}) map Out[10]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[11]: Copied! <pre>import maeson\nfrom maeson.gistory import SceneBuilder\n\nm = maeson.Map(center=(0, 0), zoom=2)\nbuilder = SceneBuilder(m)\nbuilder.display()\n</pre> import maeson from maeson.gistory import SceneBuilder  m = maeson.Map(center=(0, 0), zoom=2) builder = SceneBuilder(m) builder.display() In\u00a0[12]: Copied! <pre>## Raster layer\n# -22.1757, -51.2527\n# https://github.com/opengeos/datasets/releases/download/samgeo/tree_image.tif\n\n## Image layer\n# https://i.imgur.com/06Q1fSz.png\n# ((13, -130), (32, -100))\n\n# # June 2021 Sentinel\u20112 mosaic using highest-NDVI pixel\n# import ee\n# ee.Initialize()\n# sentinel = (\n#     ee.ImageCollection(\"COPERNICUS/S2_SR\")\n#       .filterDate(\"2021-06-01\", \"2021-06-30\")\n#       .filterBounds(ee.Geometry.Point(-122.4, 37.8))\n# )\n\n# map.add_earthengine(\n#     ee_object=sentinel,\n#     vis_params={\n#         \"bands\": [\"B4\", \"B3\", \"B2\"],\n#         \"min\": 0,\n#         \"max\": 3000\n#     },\n#     name=\"Sentinel-2 True Color (Jun 2021)\"\n# )\n\n# Annual mean NDVI from MODIS\n# import ee\n# ee.Initialize()\n# ndvi = (\n#     ee.ImageCollection(\"MODIS/006/MOD13A1\")\n#       .select(\"NDVI\")\n#       .filterDate(\"2021-01-01\", \"2021-12-31\")\n#       .mean()\n# )\n\n# map.add_earthengine(\n#     ee_object=ndvi,\n#     vis_params={\n#         \"min\": 0,\n#         \"max\": 9000,\n#         \"palette\": [\"white\", \"yellow\", \"green\"]\n#     },\n#     name=\"MODIS NDVI 2021\"\n# )\n</pre> ## Raster layer # -22.1757, -51.2527 # https://github.com/opengeos/datasets/releases/download/samgeo/tree_image.tif  ## Image layer # https://i.imgur.com/06Q1fSz.png # ((13, -130), (32, -100))  # # June 2021 Sentinel\u20112 mosaic using highest-NDVI pixel # import ee # ee.Initialize() # sentinel = ( #     ee.ImageCollection(\"COPERNICUS/S2_SR\") #       .filterDate(\"2021-06-01\", \"2021-06-30\") #       .filterBounds(ee.Geometry.Point(-122.4, 37.8)) # )  # map.add_earthengine( #     ee_object=sentinel, #     vis_params={ #         \"bands\": [\"B4\", \"B3\", \"B2\"], #         \"min\": 0, #         \"max\": 3000 #     }, #     name=\"Sentinel-2 True Color (Jun 2021)\" # )  # Annual mean NDVI from MODIS # import ee # ee.Initialize() # ndvi = ( #     ee.ImageCollection(\"MODIS/006/MOD13A1\") #       .select(\"NDVI\") #       .filterDate(\"2021-01-01\", \"2021-12-31\") #       .mean() # )  # map.add_earthengine( #     ee_object=ndvi, #     vis_params={ #         \"min\": 0, #         \"max\": 9000, #         \"palette\": [\"white\", \"yellow\", \"green\"] #     }, #     name=\"MODIS NDVI 2021\" # )"},{"location":"examples/usage/#example-code-usage","title":"Example Code Usage\u00b6","text":""},{"location":"examples/usage/#ipyleaflet-functionality","title":"ipyleaflet Functionality\u00b6","text":""},{"location":"examples/usage/#vector-data","title":"Vector Data\u00b6","text":""},{"location":"examples/usage/#raster-data","title":"Raster Data\u00b6","text":""},{"location":"examples/usage/#imagegifs","title":"Image/GIFs\u00b6","text":""},{"location":"examples/usage/#video-layers","title":"Video Layers\u00b6","text":""},{"location":"examples/usage/#wms-layers","title":"WMS Layers\u00b6","text":""},{"location":"examples/usage/#basemap-widget","title":"Basemap Widget\u00b6","text":""},{"location":"examples/usage/#folium-functionality","title":"Folium Functionality\u00b6","text":""},{"location":"examples/usage/#gistory","title":"gistory\u00b6","text":""},{"location":"examples/usage/#scenebuilder","title":"SceneBuilder\u00b6","text":""}]}