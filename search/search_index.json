{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to maeson","text":"<p>Geospatial software for raster and point cloud processing.</p> <p>Sure! Here's the <code>homepage.md</code> in proper Markdown format:</p>"},{"location":"#welcome-to-maeson_1","title":"Welcome to MAESon \ud83c\udf0d\ud83e\udd16","text":"<p>MAESon (Machine Learning and Artificial Intelligence for Earth Science) is an open-source geospatial software package that harnesses the power of AI and machine learning to analyze Earth science data. Whether you're working with remote sensing imagery, hydrological models, or ecological datasets, MAESon provides cutting-edge tools to extract meaningful insights.</p>"},{"location":"#why-maeson","title":"Why MAESon? \ud83d\ude80","text":"<ul> <li>AI-Powered Geospatial Analysis: Integrates machine learning models for classification, prediction, and feature extraction.</li> <li>Remote Sensing Support: Works with multispectral, hyperspectral, and LiDAR data.</li> <li>Hydrological &amp; Ecological Tools: Analyze land cover, water bodies, and vegetation changes.</li> <li>Seamless GIS Integration: Compatible with GDAL, QGIS, and other geospatial tools.</li> <li>Open-Source &amp; Community-Driven: Built for researchers, by researchers.</li> </ul>"},{"location":"#getting-started","title":"Getting Started \ud83d\udca1","text":"<p>Ready to dive in? Follow these steps to set up MAESon on your machine:</p>"},{"location":"#1-install-maeson","title":"1. Install MAESon","text":"<pre><code>pip install maeson\n</code></pre>"},{"location":"#2-load-your-data","title":"2. Load Your Data","text":"<pre><code>import maeson\ndata = maeson.load_raster(\"path/to/your/data.tif\")\n</code></pre>"},{"location":"#3-run-analysis","title":"3. Run Analysis","text":"<pre><code>result = maeson.process_raster(data, model=\"random_forest\")\n</code></pre>"},{"location":"#learn-more","title":"Learn More \ud83d\udcda","text":"<ul> <li>Installation Guide \u2013 Step-by-step setup instructions.</li> <li>User Guide \u2013 Explore core functionalities and examples.</li> <li>API Reference \u2013 Detailed documentation on available methods.</li> <li>Contributing \u2013 Join the MAESon development community!</li> </ul>"},{"location":"#stay-connected","title":"Stay Connected \ud83d\udcac","text":"<ul> <li>GitHub: github.com/yourusername/MAESon</li> <li>Discussions &amp; Issues: Submit questions, feature requests, or bug reports.</li> <li>Community Contributions: Help improve MAESon by contributing code, documentation, or use cases.</li> </ul> <p>\ud83d\ude80 Get started today and bring AI-powered insights to your geospatial data!</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v003-date","title":"v0.0.3 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"common/","title":"common module","text":"<p>The common module contains common functions and classes used by the other modules.</p>"},{"location":"common/#maeson.common.hello_world","title":"<code>hello_world()</code>","text":"<p>Prints \"Hello World!\" to the console.</p> Source code in <code>maeson/common.py</code> <pre><code>def hello_world():\n    \"\"\"Prints \"Hello World!\" to the console.\"\"\"\n    print(\"Hello World!\")\n</code></pre>"},{"location":"contributing/","title":"Contributing to MAESon \ud83e\udd1d\ud83d\ude80","text":"<p>Thank you for your interest in contributing to MAESon! We welcome contributions of all kinds, including bug fixes, new features, documentation improvements, and discussions.</p>"},{"location":"contributing/#how-to-contribute","title":"How to Contribute \ud83d\udccc","text":""},{"location":"contributing/#1-fork-the-repository","title":"1. Fork the Repository","text":"<p>Click the Fork button at the top of the MAESon GitHub repository, and clone it to your local machine: <pre><code>git clone https://github.com/yourusername/MAESon.git\ncd MAESon\n</code></pre></p>"},{"location":"contributing/#2-create-a-branch","title":"2. Create a Branch","text":"<p>Create a new branch for your feature or bug fix: <pre><code>git checkout -b feature-xyz\n</code></pre></p>"},{"location":"contributing/#3-install-dependencies","title":"3. Install Dependencies","text":"<p>Ensure you have all necessary dependencies installed: <pre><code>pip install -r requirements.txt\n</code></pre> For development, install additional dependencies: <pre><code>pip install -r requirements-dev.txt\n</code></pre></p>"},{"location":"contributing/#4-make-your-changes","title":"4. Make Your Changes","text":"<p>Modify the codebase and test your changes. If adding a new feature, update the documentation accordingly.</p>"},{"location":"contributing/#5-run-tests","title":"5. Run Tests \u2705","text":"<p>Ensure all tests pass before submitting a pull request: <pre><code>pytest\n</code></pre></p>"},{"location":"contributing/#6-commit-and-push-changes","title":"6. Commit and Push Changes","text":"<pre><code>git add .\ngit commit -m \"Add feature XYZ\"\ngit push origin feature-xyz\n</code></pre>"},{"location":"contributing/#7-submit-a-pull-request","title":"7. Submit a Pull Request","text":"<p>Go to the MAESon repository on GitHub, navigate to the Pull Requests tab, and submit a new pull request. Provide a clear description of the changes you've made.</p>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues \ud83d\udc1e","text":"<p>If you encounter a bug, please report it by opening an issue on GitHub Issues. Provide as much detail as possible, including: - Steps to reproduce the issue - Expected behavior - Actual behavior - Screenshots or error logs (if applicable)</p>"},{"location":"contributing/#code-style-guidelines","title":"Code Style Guidelines \u2728","text":"<ul> <li>Follow PEP 8 for Python code style.</li> <li>Use type hints where applicable.</li> <li>Write docstrings for all functions and classes.</li> </ul>"},{"location":"contributing/#documentation-contributions","title":"Documentation Contributions \ud83d\udcd6","text":"<p>We also welcome contributions to our documentation! If you'd like to improve or add new sections, edit the markdown files in the <code>docs/</code> directory and submit a pull request.</p>"},{"location":"contributing/#join-the-discussion","title":"Join the Discussion \ud83d\udcac","text":"<p>Want to discuss a feature before implementing it? Join the Discussions tab or open an issue to propose new ideas!</p> <p>\ud83d\ude80 Thank you for contributing to MAESon! Your support helps make geospatial AI more accessible and powerful.</p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"folmap/","title":"<code>folmap</code>: Enhanced Interactive Mapping with Folium","text":"<p><code>folmap</code> is a lightweight Python module that extends the functionality of <code>folium</code> for interactive web maps. It simplifies adding common geospatial data formats like shapefiles, GeoJSON, and raster overlays, and includes helpers for split maps and Esri basemaps.</p>"},{"location":"folmap/#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"folmap/#installation","title":"\ud83d\udce6 Installation","text":"<p>Install the required dependencies:</p> <pre><code>pip install folium geopandas\n</code></pre> <p>Add <code>folmap.py</code> to your project or install it from your package repository (if published on PyPI):</p> <pre><code>pip install folmap\n</code></pre>"},{"location":"folmap/#class-map","title":"\ud83e\udded Class: <code>Map</code>","text":"<pre><code>from folmap import Map\n</code></pre> <p>An enhanced subclass of <code>folium.Map</code> that adds built-in support for:</p> <ul> <li>\ud83d\udccc Esri basemaps</li> <li>\ud83e\udde9 GeoJSON and shapefiles</li> <li>\ud83c\udf3f GeoDataFrames</li> <li>\ud83d\uddbc\ufe0f Raster overlays</li> <li>\ud83d\udd00 Side-by-side (split) basemap comparison</li> </ul>"},{"location":"folmap/#constructor","title":"Constructor","text":"<pre><code>Map(center=(0, 0), zoom=2, **kwargs)\n</code></pre> <p>Arguments:</p> <ul> <li><code>center</code> (tuple): Latitude and longitude of the map center.</li> <li><code>zoom</code> (int): Initial zoom level.</li> <li><code>**kwargs</code>: Additional keyword arguments for <code>folium.Map</code>.</li> </ul>"},{"location":"folmap/#methods","title":"\ud83d\udd27 Methods","text":""},{"location":"folmap/#add_basemapname-str-kwargs","title":"<code>add_basemap(name: str, **kwargs)</code>","text":"<p>Adds an Esri basemap to the map.</p> <p>Arguments:</p> <ul> <li><code>name</code> (str): One of the following: <code>\"Road\"</code>, <code>\"Satellite\"</code>, <code>\"Topo\"</code>, <code>\"Terrain\"</code>.</li> <li><code>**kwargs</code>: Additional options passed to <code>folium.TileLayer</code>.</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code>: If the name is not supported.</li> </ul>"},{"location":"folmap/#add_geojsondata-namegeojson-layer-kwargs","title":"<code>add_geojson(data, name=\"GeoJSON Layer\", **kwargs)</code>","text":"<p>Adds GeoJSON data from a file path or dictionary.</p> <p>Arguments:</p> <ul> <li><code>data</code> (str or dict): Path to a GeoJSON file or a Python dictionary.</li> <li><code>name</code> (str): Layer name for the legend.</li> <li><code>**kwargs</code>: Additional keyword arguments for <code>folium.GeoJson</code>.</li> </ul>"},{"location":"folmap/#add_shpdata-str-kwargs","title":"<code>add_shp(data: str, **kwargs)</code>","text":"<p>Adds a shapefile layer to the map.</p> <p>Arguments:</p> <ul> <li><code>data</code> (str): Path to a <code>.shp</code> file (shapefile).</li> <li><code>**kwargs</code>: Passed to the underlying <code>add_geojson</code> method.</li> </ul>"},{"location":"folmap/#add_gdfgdf-namegdf-layer-kwargs","title":"<code>add_gdf(gdf, name=\"GDF Layer\", **kwargs)</code>","text":"<p>Adds a <code>GeoDataFrame</code> to the map.</p> <p>Arguments:</p> <ul> <li><code>gdf</code> (geopandas.GeoDataFrame): The spatial data.</li> <li><code>name</code> (str): Layer name.</li> <li><code>**kwargs</code>: Optional style parameters.</li> </ul>"},{"location":"folmap/#add_vectordata-namevector-layer-kwargs","title":"<code>add_vector(data, name=\"Vector Layer\", **kwargs)</code>","text":"<p>Generic method for adding any vector data type.</p> <p>Arguments:</p> <ul> <li><code>data</code> (str, dict, or GeoDataFrame): File path, GeoJSON, or GeoDataFrame.</li> <li><code>name</code> (str): Layer name.</li> <li><code>**kwargs</code>: Passed to internal rendering methods.</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code>: If the data type is unsupported.</li> </ul>"},{"location":"folmap/#add_layer_control","title":"<code>add_layer_control()</code>","text":"<p>Adds a layer switcher widget to toggle visibility of basemaps and layers.</p>"},{"location":"folmap/#add_rasterdata-str-layer_name-str-kwargs","title":"<code>add_raster(data: str, layer_name: str, **kwargs)</code>","text":"<p>Adds a raster overlay image (e.g., PNG, TIFF) to the map.</p> <p>Arguments:</p> <ul> <li><code>data</code> (str): File path or URL to the image.</li> <li><code>layer_name</code> (str): Display name for the raster layer.</li> <li><code>**kwargs</code>: Additional options for <code>folium.ImageOverlay</code>.</li> </ul>"},{"location":"folmap/#add_split_mapleftopenstreetmap-rightcartodbpositron-kwargs","title":"<code>add_split_map(left=\"openstreetmap\", right=\"cartodbpositron\", **kwargs)</code>","text":"<p>Creates a side-by-side comparison of two basemaps or raster layers.</p> <p>Arguments:</p> <ul> <li><code>left</code> (str): Left layer name or file path.</li> <li><code>right</code> (str): Right layer name or file path.</li> <li><code>**kwargs</code>: Additional display options for both layers.</li> </ul> <p>Supports:</p> <ul> <li>Standard folium basemap names (<code>\"openstreetmap\"</code>, <code>\"stamenterrain\"</code>, etc.)</li> <li>Tiled image files (<code>.tif</code>, <code>.png</code>)</li> </ul>"},{"location":"folmap/#example","title":"\ud83e\uddea Example","text":"<pre><code>from folmap import Map\n\n# Initialize the map\nm = Map(center=(35.95, -83.92), zoom=8)\n\n# Add a basemap\nm.add_basemap(\"Satellite\")\n\n# Add a shapefile\nm.add_shp(\"data/watersheds.shp\", name=\"Watersheds\")\n\n# Add raster overlay\nm.add_raster(\"data/ndvi_overlay.tif\", layer_name=\"NDVI Overlay\", opacity=0.6)\n\n# Layer control and export\nm.add_layer_control()\nm.save(\"interactive_map.html\")\n</code></pre>"},{"location":"gistory/","title":"gistory","text":"<p>gistory is a lightweight Python module for building interactive geographic storytelling in Jupyter notebooks. It provides a simple API to define map-based \"scenes\" and navigate through them with smooth transitions, dynamic layer loading, and interactive widgets.</p>"},{"location":"gistory/#features","title":"Features","text":"<ul> <li>Scene definition: Specify map center, zoom level, caption, and overlay layers (tile, GeoJSON, raster, image).</li> <li>Story sequencing: Organize multiple <code>Scene</code> objects into a <code>Story</code> that can be navigated sequentially.</li> <li>Interactive controls: <code>StoryController</code> renders Next/Back buttons, captions, and map updates in Jupyter.</li> <li>Layer handling: Leverage built-in <code>maeson.Map</code> methods (<code>add_tile</code>, <code>add_geojson</code>, <code>add_raster</code>, <code>add_image</code>, <code>add_wms</code>, <code>add_earthengine</code>) for clean integration.</li> <li>Scene authoring: <code>SceneBuilder</code> widget allows users to construct, preview, edit, and export scenes interactively.</li> <li>Export &amp; import: Save and load entire stories to/from JSON for later reuse or sharing.</li> </ul>"},{"location":"gistory/#installation","title":"Installation","text":"<pre><code>pip install maeson  # includes gistory submodule\n# or if standalone:\npip install gistory\n</code></pre> <p>Ensure you have Jupyter, ipyleaflet, and ipywidgets enabled:</p> <pre><code>pip install jupyterlab ipyleaflet ipywidgets\njupyter nbextension enable --py --sys-prefix ipyleaflet\njupyter nbextension enable --py --sys-prefix widgetsnbextension\n</code></pre>"},{"location":"gistory/#quick-start","title":"Quick Start","text":"<pre><code>from maeson.gistory import Scene, Story, StoryController\nfrom ipyleaflet import Map\n\n# 1. Prepare a base map\nm = Map(center=(0, 0), zoom=2)\n\n# 2. Define scenes\nscenes = [\n    Scene(\n        center=(37.7749, -122.4194), zoom=10,\n        caption=\"San Francisco\",\n        layers=[\n            {\"type\": \"tile\", \"url\": \"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"},\n            {\"type\": \"geojson\", \"path\": \"data/sf.geojson\", \"name\": \"SF Zones\"}\n        ],\n        title=\"SF Overview\",\n        order=1\n    ),\n    Scene(\n        center=(48.8566, 2.3522), zoom=12,\n        caption=\"Paris Historical Map\",\n        layers=[\n            {\"type\": \"tile\", \"url\": \"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"},\n            {\"type\": \"image\", \"url\": \"https://upload.wikimedia.org/wikipedia/commons/d/d2/Plan_de_Paris_1857.png\", \"bounds\": [[48.835, 2.26], [48.885, 2.40]]}\n        ],\n        title=\"Paris 1857\",\n        order=2\n    )\n]\n\n# 3. Build story and controller\nstory = Story(scenes)\ncontroller = StoryController(story, m)\ncontroller.display()\n</code></pre>"},{"location":"gistory/#api-reference","title":"API Reference","text":""},{"location":"gistory/#maeson.gistory.SceneBuilder","title":"<code> SceneBuilder        </code>","text":"Source code in <code>maeson/gistory.py</code> <pre><code>class SceneBuilder:\n    def __init__(self, maeson_map):\n        # Core state\n        self.map = maeson_map\n        self.layers = []  # holds layer definitions\n        self.story = []  # holds saved Scene objects\n        self.log_history = []  # for console logging\n\n        # Map view &amp; metadata fields\n        self.lat = widgets.FloatText(description=\"Lat\", value=0)\n        self.lon = widgets.FloatText(description=\"Lon\", value=0)\n        self.zoom = widgets.IntSlider(description=\"Zoom\", min=1, max=18, value=2)\n        self.caption = widgets.Text(description=\"Caption\")\n\n        # Zoom slider directly to map.zoom\n        jslink((self.zoom, \"value\"), (self.map, \"zoom\"))\n\n        # For center, we\u2019ll do observers:\n        self.lat.observe(\n            lambda change: self._update_map_center(lat=change[\"new\"]), names=\"value\"\n        )\n        self.lon.observe(\n            lambda change: self._update_map_center(lon=change[\"new\"]), names=\"value\"\n        )\n\n        # Link map to widgets \u2014\n\n        self.map.observe(self._on_map_center_change, names=\"center\")\n        self.map.observe(self._on_map_zoom_change, names=\"zoom\")\n\n        self.title = widgets.Text(description=\"Title\", placeholder=\"Scene Title\")\n        self.order_input = widgets.IntText(description=\"Order\", value=1, min=1)\n        self.sort_chrono = widgets.Checkbox(\n            description=\"Sort Chronologically\", value=False\n        )\n\n        # Layer entry widgets\n        self.layer_src = widgets.Text(description=\"URL/path\")\n        self.bounds = widgets.Text(\n            description=\"Bounds (Optional)\", placeholder=\"((S_min,W_min),(N_max,E_max))\"\n        )\n        self.ee_id = widgets.Text(\n            description=\"EE ID\", placeholder=\"e.g. USGS/SRTMGL1_003\"\n        )\n        self.ee_vis = widgets.Textarea(\n            description=\"vis_params\", placeholder='{\"min\":0}'\n        )\n\n        # Scene list controls\n        self.scene_selector = widgets.Dropdown(\n            options=[], description=\"Scenes\", layout=widgets.Layout(width=\"300px\")\n        )\n        self.scene_selector.observe(self._on_scene_select, names=\"value\")\n\n        # Action buttons: Preview, Save, Update, Delete, Export, Present\n        self.preview_button = widgets.Button(description=\"Preview\")\n        self.save_scene_button = widgets.Button(description=\"\ud83d\udcbe Save Scene\")\n        self.update_button = widgets.Button(description=\"Update\")\n        self.delete_button = widgets.Button(description=\"Delete\")\n        self.export_button = widgets.Button(description=\"Export Story\", icon=\"save\")\n        self.present_button = widgets.Button(\n            description=\"\u25b6\ufe0f Present\", button_style=\"success\"\n        )\n\n        self.layer_src.layout = widgets.Layout(width=\"50%\")\n        self.caption.layout = widgets.Layout(width=\"30%\")\n        self.bounds.layout = widgets.Layout(width=\"20%\")\n\n        # wire up callbacks\n        self.preview_button.on_click(self.preview_scene)\n        self.save_scene_button.on_click(self.save_scene)\n        self.update_button.on_click(self.update_scene)\n        self.delete_button.on_click(self.delete_scene)\n        self.export_button.on_click(self.export_story)\n        self.present_button.on_click(self._enter_present_mode)\n        self.edit_button = widgets.Button(\n            description=\"\u270f\ufe0f Edit\", tooltip=\"Return to editor\", button_style=\"info\"\n        )\n        self.edit_button.on_click(self._exit_present_mode)\n\n        self.scene_controls = widgets.HBox(\n            [\n                self.scene_selector,\n                self.save_scene_button,\n                self.preview_button,\n                self.update_button,\n                self.delete_button,\n                self.export_button,\n                self.present_button,\n            ],\n            layout=widgets.Layout(gap=\"10px\"),\n        )\n\n        # Logging widgets\n        self.output = widgets.Output(\n            layout=widgets.Layout(\n                display=\"block\",\n                border=\"1px solid gray\",\n                padding=\"6px\",\n                max_height=\"150px\",\n                overflow=\"auto\",\n            )\n        )\n        self.toggle_log_button = widgets.ToggleButton(\n            value=True, description=\"Hide Log\", icon=\"eye-slash\"\n        )\n        self.toggle_log_button.observe(self.toggle_log_output, names=\"value\")\n\n        self.custom_code = widgets.Textarea(\n            value=(\n                \"# Enter Python code here using the variable `map`.\\n\"\n                \"# e.g. map.add_heatmap(data='points.csv', latitude='lat', longitude='lon')\"\n            ),\n            placeholder=\"Write Python snippet\u2026\",\n            layout=Layout(width=\"100%\", height=\"150px\"),\n        )\n        self.run_code_button = widgets.Button(\n            description=\"Run Code\",\n            button_style=\"info\",\n            tooltip=\"Execute the code above\",\n        )\n        self.run_code_button.on_click(self._run_custom_code)\n\n        # 2) Wrap them in a container we'll show/hide\n        self.code_container = VBox(\n            [\n                HTML(\"&lt;b&gt;Custom Python:&lt;/b&gt;\"),\n                self.custom_code,\n                self.run_code_button,\n            ],\n            layout=Layout(display=\"block\", gap=\"6px\"),\n        )\n\n        # 3) Build your two toggle buttons\n        self.toggle_log_button = ToggleButton(\n            value=True, description=\"Hide Log\", icon=\"list\", tooltip=\"Show/hide log\"\n        )\n        self.toggle_log_button.observe(self.toggle_log_output, names=\"value\")\n\n        self.toggle_code_button = ToggleButton(\n            value=True,\n            description=\"Hide Code\",\n            icon=\"code\",\n            tooltip=\"Show/hide Python shell\",\n        )\n        self.toggle_code_button.observe(self._toggle_code, names=\"value\")\n\n        # 4) Put the toggles side\u2010by\u2010side\n        self.toggle_row = HBox(\n            [self.toggle_log_button, self.toggle_code_button], layout=Layout(gap=\"10px\")\n        )\n\n        # 5) Grab your map widget\n        map_widget = getattr(self.map, \"map\", self.map)\n\n        # 6) Finally build the authoring UI in one shot\n        self.builder_ui = VBox(\n            [\n                map_widget,\n                self.scene_controls,\n                HBox([self.title, self.order_input, self.sort_chrono]),\n                HBox([self.lat, self.lon, self.zoom]),\n                HBox(\n                    [self.layer_src, self.caption, self.bounds],\n                    layout=Layout(gap=\"10px\"),\n                ),\n                HBox([self.ee_id, self.ee_vis]),\n                self.toggle_row,  # both toggles here\n                self.output,\n                self.code_container,  # code editor below\n            ],\n            layout=Layout(gap=\"10px\"),\n        )\n\n        # 7) Wrap into your main container\n        self.main_container = VBox([self.builder_ui])\n\n    def display(self):\n        from IPython.display import display\n\n        display(self.main_container)\n\n    def add_layer(self, _=None, commit=True):\n        path = self.layer_src.value.strip()\n        lt = self.detect_layer_type(path)\n        name = f\"{lt.upper()}-{len(self.layers)}\"\n\n        if lt == \"tile\":\n            self.map.add_tile(url=path, name=name)\n        elif lt == \"geojson\":\n            self.map.add_geojson(path=path, name=name)\n        elif lt == \"image\":\n            bounds = eval(self.bounds.value)\n            self.map.add_image(url=path, bounds=bounds, name=name)\n        elif lt == \"raster\":\n            self.map.add_raster(path)\n        elif lt == \"wms\":\n            self.map.add_wms_layer(url=path, name=name)\n        elif lt == \"video\":\n            self.map.add_video(path, name=name)\n        elif lt == \"earthengine\":\n            ee_id = self.ee_id.value.strip()\n            vis = json.loads(self.ee_vis.value or \"{}\")\n            self.map.add_earthengine(ee_id=ee_id, vis_params=vis, name=name)\n        else:\n            return self.log(f\"\u274c Could not detect layer type for: {path}\")\n\n        # only append if commit\n        if commit:\n            self.layers.append(\n                {\n                    \"type\": lt,\n                    \"path\": path,\n                    \"name\": name,\n                    \"bounds\": eval(self.bounds.value) if lt == \"image\" else None,\n                    \"ee_id\": self.ee_id.value.strip() if lt == \"earthengine\" else None,\n                    \"vis_params\": (\n                        json.loads(self.ee_vis.value or \"{}\")\n                        if lt == \"earthengine\"\n                        else None\n                    ),\n                }\n            )\n        self.log(f\"\u2705 Added {lt} layer: {name}\")\n\n    def save_scene(self, _=None):\n        # 1) Read metadata\n        scene_title = self.title.value.strip() or f\"Scene {len(self.story)+1}\"\n        scene_order = self.order_input.value\n        code = self.custom_code.value or \"\"\n\n        # 2) Prepare the layer list (copy of what\u2019s been added so far)\n        layers = self.layers.copy()\n\n        # 3) If the user has drawn any ROIs, include them as GeoJSON\n        if hasattr(self, \"drawn_features\") and self.drawn_features:\n            layers.append(\n                {\n                    \"type\": \"geojson\",\n                    \"data\": {\n                        \"type\": \"FeatureCollection\",\n                        \"features\": list(self.drawn_features),\n                    },\n                    \"name\": \"ROIs\",\n                }\n            )\n\n        # 4) Build the Scene, passing that 'layers' var\n        scene = Scene(\n            center=(self.lat.value, self.lon.value),\n            zoom=self.zoom.value,\n            caption=self.caption.value,\n            layers=layers,\n            title=scene_title,\n            order=scene_order,\n            basemap=getattr(self, \"basemap_dropdown\", None)\n            and self.basemap_dropdown.value,\n            custom_code=code,\n        )\n\n        # 5) Append &amp; sort\n        self.story.append(scene)\n        self.story.sort(key=lambda s: s.order)\n\n        # 6) Refresh UI &amp; clear state\n        self.refresh_scene_list()\n        self.layers.clear()\n        if hasattr(self, \"drawn_features\"):\n            self.drawn_features.clear()\n        self.title.value = \"\"\n        self.order_input.value = len(self.story) + 1\n        self.custom_code.value = \"\"\n\n        # 7) Log success\n        self.log(f\"\u2705 Saved scene \u201c{scene_title}\u201d with {len(layers)} layer(s)\")\n\n    def refresh_scene_list(self):\n        options = []\n        for i, s in enumerate(self.story):\n            label = f\"{s.order}: {s.title or f'Scene {i+1}'}\"\n            options.append((label, i))\n        self.scene_selector.options = options\n\n    def load_scene(self, _=None):\n        # 1) Find the selected scene\n        i = self.scene_selector.index\n        if i &lt; 0:\n            return\n\n        scene = self.story[i]\n\n        # 2) Populate the form fields\n        self.lat.value, self.lon.value = scene.center\n        self.zoom.value = scene.zoom\n        self.caption.value = scene.caption\n        self.title.value = scene.title or \"\"\n        self.order_input.value = scene.order\n        self.custom_code.value = scene.custom_code\n\n        # 3) Reset our internal layer list to this scene\u2019s layers\n        #    (so we don\u2019t accumulate layers from previous edits)\n        self.layers = [ld.copy() for ld in scene.layers]\n\n        # 4) Clear existing non\u2011base layers from the map\n        for lyr in list(self.map.layers)[1:]:\n            self.map.remove_layer(lyr)\n\n        # 5) Replay just this scene\u2019s layers onto the map\n        for ld in self.layers:\n            try:\n                self._apply_layer_def(ld)\n            except Exception as e:\n                self.log(f\"\u274c Failed to apply {ld.get('name')}: {e}\")\n\n        # 6) Feedback\n        self.log(f\"Loaded scene {i}: \u201c{scene.title}\u201d\")\n\n    def update_scene(self, _):\n        i = self.scene_selector.index\n        if i &lt; 0:\n            return\n        scene = Scene(\n            center=(self.lat.value, self.lon.value),\n            zoom=self.zoom.value,\n            caption=self.caption.value,\n            layers=self.layers.copy(),\n            title=self.title.value.strip() or f\"Scene {i+1}\",\n            order=self.order_input.value,\n        )\n        self.story[i] = scene\n        self.refresh_scene_list()\n        self.log(f\"Updated scene {i}.\")\n\n    def delete_scene(self, _):\n        i = self.scene_selector.index\n        if i &lt; 0:\n            return\n        self.story.pop(i)\n        self.refresh_scene_list()\n        self.log(f\"Deleted scene {i}.\")\n\n    def preview_scene(self, _=None):\n        # 1) Read &amp; validate the source\n        src = self.layer_src.value.strip()\n        if not src:\n            return self.log(\"\u274c No URL/path entered\")\n\n        # 2) Let detect_layer_type tell us what it is\n        lt = detect_layer_type(src)\n        if lt == \"unknown\":\n            return self.log(f\"\u274c Could not detect layer type for: {src}\")\n\n        # 3) Build the new layer_def\n        name = f\"{lt.upper()}-{len(self.layers)}\"\n        layer_def = {\"type\": lt, \"name\": name}\n\n        # geojson &amp; raster need a path, others use url\n        if lt in (\"geojson\", \"raster\"):\n            layer_def[\"path\"] = src\n        else:\n            layer_def[\"url\"] = src\n\n        # 4) Extras: bounds for images, EE params for earthengine\n        if lt == \"image\":\n            try:\n                layer_def[\"bounds\"] = eval(self.bounds.value)\n            except:\n                return self.log(\"\u274c Invalid bounds syntax\")\n        elif lt == \"earthengine\":\n            ee_id = self.ee_id.value.strip()\n            try:\n                vis = json.loads(self.ee_vis.value or \"{}\")\n            except:\n                return self.log(\"\u274c Invalid EE vis_params JSON\")\n            layer_def[\"ee_id\"] = ee_id\n            layer_def[\"vis_params\"] = vis\n        elif lt == \"video\":\n            # require bounds\n            try:\n                layer_def[\"bounds\"] = eval(self.bounds.value)\n            except:\n                return self.log(\"\u274c Invalid bounds for video\")\n        elif lt == \"tile\":\n            # require bounds\n            try:\n                layer_def[\"bounds\"] = eval(self.bounds.value)\n            except:\n                return self.log(\"\u274c Invalid bounds for tile\")\n\n        # 5) Commit into the scene\u2019s layer list\n        self.layers.append(layer_def)\n\n        # 6) Reset the map view\n        self.map.center = (self.lat.value, self.lon.value)\n        self.map.zoom = self.zoom.value\n\n        # 7) Clear existing overlays (keep only base)\n        for lyr in list(self.map.layers)[1:]:\n            self.map.remove_layer(lyr)\n\n        # 8) Replay all saved layers via your helper\n        for ld in self.layers:\n            try:\n                self._apply_layer_def(ld)\n            except Exception as e:\n                self.log(f\"\u274c Failed to apply {ld['name']}: {e}\")\n\n        # 9) Final feedback\n        self.log(f\"\u2705 Previewed scene with {len(self.layers)} layers\")\n\n    def log(self, message):\n        \"\"\"\n        Append a message and then render:\n        \u2022 full history if toggle is ON\n        \u2022 just the last message if toggle is OFF\n        \"\"\"\n        self.log_history.append(message)\n        # Always render (we\u2019re never truly hiding)\n        if self.toggle_log_button.value:\n            self._render_log()\n        else:\n            with self.output:\n                self.output.clear_output(wait=True)\n                print(self.log_history[-1])\n\n    def toggle_log_output(self, change):\n        \"\"\"\n        Toggle between full\u2010history view (True) and\n        most\u2010recent\u2010only view (False).\n        \"\"\"\n        # Always keep the console visible\n        self.output.layout.display = \"block\"\n\n        if change[\"new\"]:\n            # Now in \u201cfull history\u201d mode\n            self.toggle_log_button.description = \"Show Recent\"\n            self.toggle_log_button.icon = \"eye-slash\"\n            self._render_log()\n        else:\n            # Now in \u201crecent only\u201d mode\n            self.toggle_log_button.description = \"Show All\"\n            self.toggle_log_button.icon = \"eye\"\n            with self.output:\n                self.output.clear_output(wait=True)\n                if self.log_history:\n                    print(self.log_history[-1])\n\n    def _on_scene_select(self, change):\n        \"\"\"Automatically load &amp; preview whenever the dropdown changes.\"\"\"\n        if change[\"new\"] is None:\n            return\n        # reuse your existing handlers\n        self.load_scene(None)\n        self.preview_scene(None)\n\n    def export_story(self, _=None):\n        \"\"\"\n        Dump all scenes to story.json and display a download link.\n        \"\"\"\n        # Build serializable list of dicts\n        out = []\n        for s in self.story:\n            out.append(\n                {\n                    \"title\": s.title,\n                    \"order\": s.order,\n                    \"center\": list(s.center),\n                    \"zoom\": s.zoom,\n                    \"caption\": s.caption,\n                    \"layers\": s.layers,\n                }\n            )\n        # Write to file\n        fn = \"story.json\"\n        with open(fn, \"w\") as f:\n            json.dump(out, f, indent=2)\n        # Log and show link\n        self.log(f\"\u2705 Story exported to {fn}\")\n        display(FileLink(fn))\n\n    def _load_def_into_ui(self, layer_def):\n        \"\"\"\n        Copy a saved layer definition back into the builder widgets\n        so that preview_scene can pick it up.\n        \"\"\"\n        # URL or local path:\n        self.layer_src.value = layer_def.get(\"path\") or layer_def.get(\"url\", \"\")\n\n        # If it\u2019s an image overlay, restore the bounds text:\n        if layer_def[\"type\"] == \"image\":\n            self.bounds.value = repr(layer_def[\"bounds\"])\n\n        # If it\u2019s an Earth Engine layer, restore ID and vis params:\n        if layer_def[\"type\"] == \"earthengine\":\n            self.ee_id.value = layer_def.get(\"ee_id\", \"\")\n            self.ee_vis.value = json.dumps(layer_def.get(\"vis_params\", {}))\n\n    def _apply_layer_def(self, ld):\n        \"\"\"\n        Load a single saved layer_def dict directly onto the map.\n        \"\"\"\n        t = ld[\"type\"]\n        name = ld.get(\"name\", None)\n\n        self.log(f\"\u2192 Applying {t} layer: {name or ld['path']}\")\n\n        if t == \"tile\":\n            self.map.add_tile(url=ld[\"path\"], name=name)\n        if ld[\"type\"] == \"geojson\":\n            if \"data\" in ld:\n                layer = GeoJSON(data=ld[\"data\"], name=ld.get(\"name\"))\n            else:\n                layer = GeoJSON(data=open(ld[\"path\"]).read(), name=ld.get(\"name\"))\n            self.map.add_layer(layer)\n        elif t == \"image\":\n            self.map.add_image(url=ld[\"path\"], bounds=ld[\"bounds\"], name=name)\n        elif t == \"raster\":\n            self.map.add_raster(ld[\"path\"], name=name)\n        elif t == \"wms\":\n            self.map.add_wms_layer(url=ld[\"path\"], name=name)\n        elif t == \"video\":\n            self.map.add_video(ld[\"path\"], name=name)\n        elif t == \"earthengine\":\n            import ee\n\n            vis = ld.get(\"vis_params\", {})\n            self.map.add_earthengine(ee_id=ld[\"ee_id\"], vis_params=vis, name=name)\n        else:\n            self.log(f\"\u274c Unknown layer type: {t}\")\n\n    def _enter_present_mode(self, _=None):\n        # 1) Build the StoryController\n        scenes = sorted(self.story, key=lambda s: s.order)\n        story_obj = Story(scenes)\n        teller = StoryController(story_obj, self.map)\n\n        # 2) Replace main_container with [edit_button row, presenter]\n        header = widgets.HBox(\n            [self.edit_button], layout=widgets.Layout(justify_content=\"flex-end\")\n        )\n        self.main_container.children = [header, teller.interface]\n\n    def _exit_present_mode(self, _=None):\n        # Simply restore the builder UI as the sole child\n        self.main_container.children = [self.builder_ui]\n\n    def _render_log(self):\n        \"\"\"\n        Clear and print every message in log_history.\n        \"\"\"\n        with self.output:\n            self.output.clear_output(wait=True)\n            for msg in self.log_history:\n                print(msg)\n\n    def _update_map_center(self, lat=None, lon=None):\n        \"\"\"Re\u2011center map when one of the text fields changes.\"\"\"\n        old_lat, old_lon = self.map.center\n        new_lat = lat if lat is not None else old_lat\n        new_lon = lon if lon is not None else old_lon\n        # This will in turn fire the observer below to update the other widget\n        self.map.center = (new_lat, new_lon)\n\n    def _on_map_center_change(self, change):\n        \"\"\"Update lat/lon fields when the map is panned.\"\"\"\n        lat, lon = change[\"new\"]\n        # avoid feedback loops by only setting if really different\n        if self.lat.value != lat:\n            self.lat.value = lat\n        if self.lon.value != lon:\n            self.lon.value = lon\n\n    def _on_map_zoom_change(self, change):\n        \"\"\"Update zoom slider when the map is zoomed.\"\"\"\n        z = change[\"new\"]\n        if self.zoom.value != z:\n            self.zoom.value = z\n\n    def _run_custom_code(self, _):\n        \"\"\"\n        Execute user\u2011entered Python with `map` in scope,\n        and log success or error.\n        \"\"\"\n        code = self.custom_code.value\n        local_ns = {\"map\": self.map}\n        try:\n            exec(code, {}, local_ns)\n            self.log(\"\u2705 Custom code executed successfully\")\n        except Exception as e:\n            # show only the last line of the traceback\n            import traceback\n\n            tb = traceback.format_exc().splitlines()[-1]\n            self.log(f\"\u274c Error: {tb}\")\n\n    def _toggle_code(self, change):\n        if change[\"new\"]:\n            self.toggle_code_button.description = \"Hide Code\"\n            self.code_container.layout.display = \"block\"\n        else:\n            self.toggle_code_button.description = \"Show Code\"\n            self.code_container.layout.display = \"none\"\n</code></pre>"},{"location":"gistory/#maeson.gistory.SceneBuilder.export_story","title":"<code>export_story(self, _=None)</code>","text":"<p>Dump all scenes to story.json and display a download link.</p> Source code in <code>maeson/gistory.py</code> <pre><code>def export_story(self, _=None):\n    \"\"\"\n    Dump all scenes to story.json and display a download link.\n    \"\"\"\n    # Build serializable list of dicts\n    out = []\n    for s in self.story:\n        out.append(\n            {\n                \"title\": s.title,\n                \"order\": s.order,\n                \"center\": list(s.center),\n                \"zoom\": s.zoom,\n                \"caption\": s.caption,\n                \"layers\": s.layers,\n            }\n        )\n    # Write to file\n    fn = \"story.json\"\n    with open(fn, \"w\") as f:\n        json.dump(out, f, indent=2)\n    # Log and show link\n    self.log(f\"\u2705 Story exported to {fn}\")\n    display(FileLink(fn))\n</code></pre>"},{"location":"gistory/#maeson.gistory.SceneBuilder.log","title":"<code>log(self, message)</code>","text":"<p>Append a message and then render: \u2022 full history if toggle is ON \u2022 just the last message if toggle is OFF</p> Source code in <code>maeson/gistory.py</code> <pre><code>def log(self, message):\n    \"\"\"\n    Append a message and then render:\n    \u2022 full history if toggle is ON\n    \u2022 just the last message if toggle is OFF\n    \"\"\"\n    self.log_history.append(message)\n    # Always render (we\u2019re never truly hiding)\n    if self.toggle_log_button.value:\n        self._render_log()\n    else:\n        with self.output:\n            self.output.clear_output(wait=True)\n            print(self.log_history[-1])\n</code></pre>"},{"location":"gistory/#maeson.gistory.SceneBuilder.toggle_log_output","title":"<code>toggle_log_output(self, change)</code>","text":"<p>Toggle between full\u2010history view (True) and most\u2010recent\u2010only view (False).</p> Source code in <code>maeson/gistory.py</code> <pre><code>def toggle_log_output(self, change):\n    \"\"\"\n    Toggle between full\u2010history view (True) and\n    most\u2010recent\u2010only view (False).\n    \"\"\"\n    # Always keep the console visible\n    self.output.layout.display = \"block\"\n\n    if change[\"new\"]:\n        # Now in \u201cfull history\u201d mode\n        self.toggle_log_button.description = \"Show Recent\"\n        self.toggle_log_button.icon = \"eye-slash\"\n        self._render_log()\n    else:\n        # Now in \u201crecent only\u201d mode\n        self.toggle_log_button.description = \"Show All\"\n        self.toggle_log_button.icon = \"eye\"\n        with self.output:\n            self.output.clear_output(wait=True)\n            if self.log_history:\n                print(self.log_history[-1])\n</code></pre>"},{"location":"gistory/#maeson.gistory.Story","title":"<code> Story        </code>","text":"Source code in <code>maeson/gistory.py</code> <pre><code>class Story:\n    def __init__(self, scenes):\n        \"\"\"\n        A sequence of scenes forming a narrative.\n        \"\"\"\n        self.scenes = scenes\n        self.index = 0\n\n    def current_scene(self):\n        return self.scenes[self.index]\n\n    def next_scene(self):\n        if self.index &lt; len(self.scenes) - 1:\n            self.index += 1\n        return self.current_scene()\n\n    def previous_scene(self):\n        if self.index &gt; 0:\n            self.index -= 1\n        return self.current_scene()\n</code></pre>"},{"location":"gistory/#maeson.gistory.Story.__init__","title":"<code>__init__(self, scenes)</code>  <code>special</code>","text":"<p>A sequence of scenes forming a narrative.</p> Source code in <code>maeson/gistory.py</code> <pre><code>def __init__(self, scenes):\n    \"\"\"\n    A sequence of scenes forming a narrative.\n    \"\"\"\n    self.scenes = scenes\n    self.index = 0\n</code></pre>"},{"location":"gistory/#maeson.gistory.StoryController","title":"<code> StoryController        </code>","text":"Source code in <code>maeson/gistory.py</code> <pre><code>class StoryController:\n    def __init__(self, story, map_obj):\n        \"\"\"\n        Connects a Story object to a map and widget-based UI.\n        \"\"\"\n        self.story = story\n        self.map = map_obj\n        self.caption = widgets.Label()\n        self.current_layers = []\n\n        self.next_button = widgets.Button(description=\"Next\")\n        self.back_button = widgets.Button(description=\"Back\")\n        self.next_button.on_click(self.next_scene)\n        self.back_button.on_click(self.previous_scene)\n\n        self.controls = widgets.HBox([self.back_button, self.next_button])\n        self.interface = widgets.VBox([self.map, self.caption, self.controls])\n\n        self.update_scene()\n\n    def update_scene(self):\n        scene = self.story.current_scene()\n        self.map.center = scene.center\n        self.map.zoom = scene.zoom\n        self.caption.value = scene.caption\n\n        # Clear previous layers\n        for layer in self.current_layers:\n            self.map.remove_layer(layer)\n        self.current_layers.clear()\n\n        # Add new layers\n        for layer_def in scene.layers:\n            if layer_def[\"type\"] == \"geojson\":\n                with open(layer_def[\"path\"]) as f:\n                    data = json.load(f)\n                layer = GeoJSON(data=data, name=layer_def.get(\"name\", \"GeoJSON\"))\n            elif layer_def[\"type\"] == \"tile\":\n                layer = TileLayer(\n                    url=layer_def[\"url\"], name=layer_def.get(\"name\", \"Tiles\")\n                )\n            elif layer_def[\"type\"] == \"image\":\n                try:\n                    bounds = layer_def[\n                        \"bounds\"\n                    ]  # Must be [[south, west], [north, east]]\n                    url = layer_def[\"url\"]\n                    layer = ImageOverlay(\n                        url=url,\n                        bounds=bounds,\n                        name=layer_def.get(\"name\", \"Image Overlay\"),\n                    )\n                except Exception as e:\n                    print(f\"Error loading image layer: {e}\")\n                    continue\n            else:\n                print(f\"Unsupported layer type: {layer_def['type']}\")\n                continue\n\n            self.map.add_layer(layer)\n            self.current_layers.append(layer)\n\n        if getattr(scene, \"custom_code\", \"\").strip():\n            try:\n                exec(\n                    scene.custom_code,\n                    {},  # no builtins unless you want\n                    {\"map\": self.map},  # give them `map`\n                )\n            except Exception as e:\n                # swallow or log; you could surface this in the UI\n                print(f\"Error in scene code: {e}\")\n\n    def next_scene(self, _=None):\n        self.story.next_scene()\n        self.update_scene()\n\n    def previous_scene(self, _=None):\n        self.story.previous_scene()\n        self.update_scene()\n\n    def display(self):\n        from IPython.display import display\n\n        display(self.interface)\n</code></pre>"},{"location":"gistory/#maeson.gistory.StoryController.__init__","title":"<code>__init__(self, story, map_obj)</code>  <code>special</code>","text":"<p>Connects a Story object to a map and widget-based UI.</p> Source code in <code>maeson/gistory.py</code> <pre><code>def __init__(self, story, map_obj):\n    \"\"\"\n    Connects a Story object to a map and widget-based UI.\n    \"\"\"\n    self.story = story\n    self.map = map_obj\n    self.caption = widgets.Label()\n    self.current_layers = []\n\n    self.next_button = widgets.Button(description=\"Next\")\n    self.back_button = widgets.Button(description=\"Back\")\n    self.next_button.on_click(self.next_scene)\n    self.back_button.on_click(self.previous_scene)\n\n    self.controls = widgets.HBox([self.back_button, self.next_button])\n    self.interface = widgets.VBox([self.map, self.caption, self.controls])\n\n    self.update_scene()\n</code></pre>"},{"location":"gistory/#layer-definitions","title":"Layer Definitions","text":"<p>Each layer is a dict specifying:</p> <ul> <li>type: one of <code>tile</code>, <code>geojson</code>, <code>image</code>, <code>raster</code>, <code>wms</code>, <code>earthengine</code>.</li> <li>url or path: source location.</li> <li>name: optional display name.</li> <li>bounds: for image overlays (<code>[[south, west], [north, east]]</code>).</li> <li>vis_params: for Earth Engine layers.</li> </ul> <p>Example: <pre><code>{\n  \"type\": \"tile\",\n  \"url\": \"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\",\n  \"name\": \"OSM\"\n}\n</code></pre></p>"},{"location":"gistory/#contributing","title":"Contributing","text":"<p>Feel free to open issues or pull requests on GitHub. New layer types and UI enhancements are welcome!</p>"},{"location":"installation/","title":"Installation Guide for MAESon \ud83d\udce6\ud83d\ude80","text":"<p>MAESon is available on PyPI, making it easy to install and use. Follow the steps below to set up MAESon on your system.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites \ud83d\udee0","text":"<p>Before installing MAESon, ensure you have the following: - Python 3.8+ installed on your system. - pip (Python package manager) updated to the latest version - Recommended: A virtual environment (e.g., <code>venv</code> or <code>conda</code>) for package management</p>"},{"location":"installation/#installation-instructions","title":"Installation Instructions \ud83d\udcbe","text":""},{"location":"installation/#1-install-via-pypi","title":"1. Install via PyPI","text":"<p>To install the latest stable release of MAESon, run: <pre><code>pip install maeson\n</code></pre></p>"},{"location":"installation/#2-verify-installation","title":"2. Verify Installation","text":"<p>To check if MAESon was installed successfully, run: <pre><code>import maeson\nprint(maeson.__version__)\n</code></pre> This should return the installed version of MAESon.</p>"},{"location":"installation/#3-optional-install-additional-dependencies","title":"3. Optional: Install Additional Dependencies","text":"<p>If you plan to use advanced features such as deep learning models or high-performance processing, install additional dependencies: <pre><code>pip install maeson[full]\n</code></pre></p>"},{"location":"installation/#upgrading-maeson","title":"Upgrading MAESon \ud83d\udd04","text":"<p>To update MAESon to the latest version, use: <pre><code>pip install --upgrade maeson\n</code></pre></p>"},{"location":"installation/#uninstalling-maeson","title":"Uninstalling MAESon \u274c","text":"<p>If you need to remove MAESon from your system, run: <pre><code>pip uninstall maeson\n</code></pre></p>"},{"location":"installation/#troubleshooting","title":"Troubleshooting \u2753","text":"<p>If you encounter any issues: - Ensure pip and setuptools are up to date:   <pre><code>pip install --upgrade pip setuptools\n</code></pre> - Check for missing dependencies and install them manually. - Report issues on GitHub Issues.</p> <p>\ud83d\ude80 You're now ready to use MAESon! Head over to the User Guide to get started.</p>"},{"location":"maeson/","title":"maeson module","text":"<p>Main module.</p> <p>Test Test</p>"},{"location":"maeson/#maeson.maeson.Map","title":"<code> Map            (Map)         </code>","text":"Source code in <code>maeson/maeson.py</code> <pre><code>class Map(Leafmap):\n    def __init__(self, *args, **kwargs):\n        kwargs.setdefault(\"toolbar_control\", False)\n        kwargs.setdefault(\"layer_control\", True)\n        super().__init__(*args, **kwargs)\n\n    def add_basemap(self, basemap=\"Esri.WorldImagery\"):\n        \"\"\"\n        Args:\n            basemap (str): Basemap name. Default is \"Esri.WorldImagery\".\n        \"\"\"\n        \"\"\"Add a basemap to the map.\"\"\"\n        basemaps = [\n            \"OpenStreetMap.Mapnik\",\n            \"Stamen.Terrain\",\n            \"Stamen.TerrainBackground\",\n            \"Stamen.Watercolor\",\n            \"Esri.WorldImagery\",\n            \"Esri.DeLorme\",\n            \"Esri.NatGeoWorldMap\",\n            \"Esri.WorldStreetMap\",\n            \"Esri.WorldTopoMap\",\n            \"Esri.WorldGrayCanvas\",\n            \"Esri.WorldShadedRelief\",\n            \"Esri.WorldPhysical\",\n            \"Esri.WorldTerrain\",\n            \"Google.Satellite\",\n            \"Google.Street\",\n            \"Google.Hybrid\",\n            \"Google.Terrain\",\n        ]\n        url = eval(f\"ipyleaflet.basemaps.{basemap}\").build_url()\n        basemap_layer = ipyleaflet.TileLayer(url=url, name=basemap)\n        self.add(basemap_layer)\n\n    def layer(self, layer) -&gt; None:\n        \"\"\"\n        Args:\n            layer (str or dict): Layer to be added to the map.\n            **kwargs: Additional arguments for the layer.\n        Returns:\n            None\n        Raises:\n            ValueError: If the layer is not a valid type.\n        \"\"\"\n        \"\"\" Convert url to layer\"\"\"\n        if isinstance(layer, str):\n            layer = ipyleaflet.TileLayer(url=layer)\n        elif isinstance(layer, dict):\n            layer = ipyleaflet.GeoJSON(data=layer)\n        elif not isinstance(layer, ipyleaflet.Layer):\n            raise ValueError(\"Layer must be an instance of ipyleaflet.Layer\")\n        return layer\n\n    def add_layer_control(self, position=\"topright\") -&gt; None:\n        \"\"\"Adds a layer control to the map.\n\n        Args:\n            position (str, optional): The position of the layer control. Defaults to 'topright'.\n        \"\"\"\n\n        self.add(ipyleaflet.LayersControl(position=position))\n\n    def add_geojson(self, geojson, **kwargs):\n        \"\"\"\n        Args:\n            geojson (dict): GeoJSON data.\n            **kwargs: Additional arguments for the GeoJSON layer.\n        \"\"\"\n        \"\"\"Add a GeoJSON layer to the map.\"\"\"\n        geojson_layer = ipyleaflet.GeoJSON(data=geojson, **kwargs)\n        self.add(geojson_layer)\n\n    def set_center(self, lat, lon, zoom=6, **kwargs):\n        \"\"\"\n        Args:\n            lat (float): Latitude of the center.\n            lon (float): Longitude of the center.\n            zoom (int): Zoom level.\n            **kwargs: Additional arguments for the map.\n        \"\"\"\n        \"\"\"Set the center of the map.\"\"\"\n        self.center = (lat, lon)\n        self.zoom = zoom\n\n    def center_object(self, obj, zoom=6, **kwargs):\n        \"\"\"\n        Args:\n            obj (str or dict): Object to center the map on.\n            zoom (int): Zoom level.\n            **kwargs: Additional arguments for the map.\n        \"\"\"\n        \"\"\"Center the map on an object.\"\"\"\n        if isinstance(obj, str):\n            obj = ipyleaflet.GeoJSON(data=obj, **kwargs)\n        elif not isinstance(obj, ipyleaflet.Layer):\n            raise ValueError(\"Object must be an instance of ipyleaflet.Layer\")\n        self.center = (obj.location[0], obj.location[1])\n        self.zoom = zoom\n\n    def add_vector(self, vector, **kwargs):\n        \"\"\"\n        Args:\n            vector (dict): Vector data.\n            **kwargs: Additional arguments for the GeoJSON layer.\n        \"\"\"\n        \"\"\"Add a vector layer to the map from Geopandas.\"\"\"\n        vector_layer = ipyleaflet.GeoJSON(data=vector, **kwargs)\n        self.add(vector_layer)\n\n    def add_raster(self, filepath, name=None, colormap=\"greys\", opacity=1, **kwargs):\n        \"\"\"\n        Add a raster (COG) layer to the map.\n\n        Parameters:\n        filepath (str): Path or URL to the cloud-optimized GeoTIFF (COG).\n        name (str, optional): Display name for the layer.\n        colormap (dict or str, optional): A colormap dictionary or a string identifier.\n        opacity (float, optional): Transparency level (default is 1 for fully opaque).\n        **kwargs: Additional keyword arguments to pass to the tile layer generator.\n        \"\"\"\n        import rasterio\n        from localtileserver import TileClient, get_leaflet_tile_layer\n\n        # Open the raster with rasterio to inspect metadata.\n        with rasterio.open(filepath) as src:\n            # If no colormap is provided (i.e., None), try extracting it from the raster's first band.\n            if colormap is None:\n                try:\n                    colormap = src.colormap(1)\n                except Exception:\n                    # Leave colormap unchanged if extraction fails.\n                    colormap = \"greys\"\n\n        # Create the tile client from the provided file path.\n        client = TileClient(filepath)\n\n        # Generate the leaflet tile layer using the provided parameters.\n        tile_layer = get_leaflet_tile_layer(\n            client, name=name, colormap=colormap, opacity=opacity, **kwargs\n        )\n\n        # Add the layer to the viewer and update the center and zoom based on the raster metadata.\n        self.add(tile_layer)\n\n    def add_image(self, url, bounds, opacity=1, **kwargs):\n        \"\"\"\n        Adds an image or animated GIF overlay to the map.\n\n        Parameters:\n            url (str): The URL of the image or GIF.\n            bounds (tuple): Geographic coordinates as ((south, west), (north, east)).\n            opacity (float, optional): The transparency level of the overlay (default is 1, fully opaque).\n            **kwargs: Additional keyword arguments for ipyleaflet.ImageOverlay.\n\n        Raises:\n            ValueError: If bounds is not provided or is improperly formatted.\n        \"\"\"\n\n        # Validate bounds: It should be a tuple of two coordinate tuples, each of length 2.\n        if not (\n            isinstance(bounds, tuple)\n            and len(bounds) == 2\n            and all(isinstance(coord, tuple) and len(coord) == 2 for coord in bounds)\n        ):\n            raise ValueError(\n                \"bounds must be a tuple in the format ((south, west), (north, east))\"\n            )\n\n        # Create the image overlay using ipyleaflet.ImageOverlay.\n        overlay = ipyleaflet.ImageOverlay(\n            url=url, bounds=bounds, opacity=opacity, **kwargs\n        )\n\n        # Add the overlay to the map.\n        self.add(overlay)\n        self.center = [\n            (bounds[0][0] + bounds[1][0]) / 2,\n            (bounds[0][1] + bounds[1][1]) / 2,\n        ]\n\n    def add_video(\n        self,\n        url: str,\n        bounds,\n        opacity: float = 1.0,\n        autoplay: bool = True,\n        loop: bool = True,\n        muted: bool = True,\n        **kwargs,\n    ):\n        \"\"\"\n        Adds a video overlay to the map using ipyleaflet.VideoOverlay.\n        \"\"\"\n        # 1) Validate &amp; normalize bounds\n        if not (\n            isinstance(bounds, (tuple, list))\n            and len(bounds) == 2\n            and all(isinstance(c, (tuple, list)) and len(c) == 2 for c in bounds)\n        ):\n            raise ValueError(\"bounds must be ((south, west), (north, east))\")\n\n        bounds = [list(bounds[0]), list(bounds[1])]\n\n        # 2) Create the VideoOverlay (url must be a string)\n        overlay = VideoOverlay(\n            url=url,\n            bounds=bounds,\n            opacity=opacity,\n            autoplay=autoplay,\n            loop=loop,\n            muted=muted,\n            **kwargs,\n        )\n\n        # 3) Add to map and fit to the bounds\n        self.add_layer(overlay)  # or self.map.add_layer if you wrap it\n        self.fit_bounds(bounds)\n\n    def add_wms_layer(self, url, layers, name, format, transparent, **kwargs):\n        \"\"\"\n        Adds a WMS (Web Map Service) layer to the map using ipyleaflet.WMSLayer.\n\n        Parameters:\n            url (str): Base WMS endpoint.\n            layers (str): Comma-separated layer names.\n            name (str): Display name for the layer.\n            format (str): Image format (e.g., 'image/png').\n            transparent (bool): Whether the WMS layer should be transparent.\n            **kwargs: Additional keyword arguments for ipyleaflet.WMSLayer.\n        \"\"\"\n\n        # Create the WMS layer using the provided parameters.\n        wms_layer = WMSLayer(\n            url=url,\n            layers=layers,\n            name=name,\n            format=format,\n            transparent=transparent,\n            **kwargs,\n        )\n\n        # Add the WMS layer to the map.\n        self.add(wms_layer)\n\n    def add_basemap_dropdown(self):\n        \"\"\"\n        Adds a dropdown + hide button as a map control.\n        Keeps track of the current basemap layer so that selecting\n        a new one removes the old and adds the new immediately.\n\n        Returns:\n            None\n        \"\"\"\n        # 1. define your choices\n        basemap_dict = {\n            \"OpenStreetMap\": basemaps.OpenStreetMap.Mapnik,\n            \"OpenTopoMap\": basemaps.OpenTopoMap,\n            \"Esri.WorldImagery\": basemaps.Esri.WorldImagery,\n            \"CartoDB.DarkMatter\": basemaps.CartoDB.DarkMatter,\n        }\n\n        # 2. build widgets\n        dropdown = widgets.Dropdown(\n            options=list(basemap_dict.keys()),\n            value=\"OpenStreetMap\",\n            layout={\"width\": \"180px\"},\n            description=\"Basemap:\",\n        )\n        hide_btn = widgets.Button(description=\"Hide\", button_style=\"danger\")\n        container = widgets.VBox([dropdown, hide_btn])\n\n        # 3. add the initial basemap layer and remember it\n        initial = basemap_dict[dropdown.value]\n        self._current_basemap = basemap_to_tiles(initial)\n        self.add_layer(self._current_basemap)\n\n        # 4. when user picks a new basemap, swap layers\n        def _on_change(change):\n            if change[\"name\"] == \"value\":\n                new_tiles = basemap_to_tiles(basemap_dict[change[\"new\"]])\n                # remove old\n                self.remove_layer(self._current_basemap)\n                # add new &amp; store reference\n                self._current_basemap = new_tiles\n                self.add_layer(self._current_basemap)\n\n        dropdown.observe(_on_change, names=\"value\")\n\n        # 5. hide control if needed\n        hide_btn.on_click(lambda _: setattr(container.layout, \"display\", \"none\"))\n\n        # 6. wrap in a WidgetControl and add to map\n        ctrl = WidgetControl(widget=container, position=\"topright\")\n        self.add_control(ctrl)\n\n    def add_earthengine(self, ee_object, vis_params=None, name=\"EE Layer\"):\n        \"\"\"\n        Adds an Earth Engine layer to the map.\n\n        Parameters\n        ----------\n        ee_object : ee.Image, ee.ImageCollection, or str\n            If str, will be wrapped as ee.Image; for ImageCollection,\n            you should reduce it (e.g. .mean()) before passing.\n        vis_params : dict, optional\n            Visualization parameters, e.g. {\"min\":0,\"max\":3000,\"palette\":[\"blue\",\"red\"]}.\n        name : str, optional\n            A display name for the layer.\n        \"\"\"\n        # 1) Initialize EE if needed\n        try:\n            ee.Initialize()\n        except Exception:\n            ee.Authenticate()\n            ee.Initialize()\n\n        # 2) Wrap strings into Images\n        if isinstance(ee_object, str):\n            ee_object = ee.Image(ee_object)\n\n        # 3) Build the TileLayer via geemap helper\n        vis_params = vis_params or {}\n        tile_layer = geemap.ee_tile_layer(ee_object, vis_params, name)\n\n        # 4) Add to the map\n        self.add_layer(tile_layer)\n\n        # 5) Optionally fit bounds (EE layers often global)\n        # comment this out if you don\u2019t want auto\u2011zoom\n        try:\n            bounds = ee_object.geometry().bounds().getInfo()[\"coordinates\"][0]\n            # bounds is [[lon, lat], \u2026], ipyleaflet wants [[lat, lon], \u2026]\n            latlng_bounds = [[lat, lon] for lon, lat in bounds]\n            self.fit_bounds(latlng_bounds)\n        except Exception:\n            pass\n\n        return tile_layer\n</code></pre>"},{"location":"maeson/#maeson.maeson.Map.add_basemap","title":"<code>add_basemap(self, basemap='Esri.WorldImagery')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Basemap name. Default is \"Esri.WorldImagery\".</p> <code>'Esri.WorldImagery'</code> Source code in <code>maeson/maeson.py</code> <pre><code>def add_basemap(self, basemap=\"Esri.WorldImagery\"):\n    \"\"\"\n    Args:\n        basemap (str): Basemap name. Default is \"Esri.WorldImagery\".\n    \"\"\"\n    \"\"\"Add a basemap to the map.\"\"\"\n    basemaps = [\n        \"OpenStreetMap.Mapnik\",\n        \"Stamen.Terrain\",\n        \"Stamen.TerrainBackground\",\n        \"Stamen.Watercolor\",\n        \"Esri.WorldImagery\",\n        \"Esri.DeLorme\",\n        \"Esri.NatGeoWorldMap\",\n        \"Esri.WorldStreetMap\",\n        \"Esri.WorldTopoMap\",\n        \"Esri.WorldGrayCanvas\",\n        \"Esri.WorldShadedRelief\",\n        \"Esri.WorldPhysical\",\n        \"Esri.WorldTerrain\",\n        \"Google.Satellite\",\n        \"Google.Street\",\n        \"Google.Hybrid\",\n        \"Google.Terrain\",\n    ]\n    url = eval(f\"ipyleaflet.basemaps.{basemap}\").build_url()\n    basemap_layer = ipyleaflet.TileLayer(url=url, name=basemap)\n    self.add(basemap_layer)\n</code></pre>"},{"location":"maeson/#maeson.maeson.Map.add_basemap_dropdown","title":"<code>add_basemap_dropdown(self)</code>","text":"<p>Adds a dropdown + hide button as a map control. Keeps track of the current basemap layer so that selecting a new one removes the old and adds the new immediately.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>maeson/maeson.py</code> <pre><code>def add_basemap_dropdown(self):\n    \"\"\"\n    Adds a dropdown + hide button as a map control.\n    Keeps track of the current basemap layer so that selecting\n    a new one removes the old and adds the new immediately.\n\n    Returns:\n        None\n    \"\"\"\n    # 1. define your choices\n    basemap_dict = {\n        \"OpenStreetMap\": basemaps.OpenStreetMap.Mapnik,\n        \"OpenTopoMap\": basemaps.OpenTopoMap,\n        \"Esri.WorldImagery\": basemaps.Esri.WorldImagery,\n        \"CartoDB.DarkMatter\": basemaps.CartoDB.DarkMatter,\n    }\n\n    # 2. build widgets\n    dropdown = widgets.Dropdown(\n        options=list(basemap_dict.keys()),\n        value=\"OpenStreetMap\",\n        layout={\"width\": \"180px\"},\n        description=\"Basemap:\",\n    )\n    hide_btn = widgets.Button(description=\"Hide\", button_style=\"danger\")\n    container = widgets.VBox([dropdown, hide_btn])\n\n    # 3. add the initial basemap layer and remember it\n    initial = basemap_dict[dropdown.value]\n    self._current_basemap = basemap_to_tiles(initial)\n    self.add_layer(self._current_basemap)\n\n    # 4. when user picks a new basemap, swap layers\n    def _on_change(change):\n        if change[\"name\"] == \"value\":\n            new_tiles = basemap_to_tiles(basemap_dict[change[\"new\"]])\n            # remove old\n            self.remove_layer(self._current_basemap)\n            # add new &amp; store reference\n            self._current_basemap = new_tiles\n            self.add_layer(self._current_basemap)\n\n    dropdown.observe(_on_change, names=\"value\")\n\n    # 5. hide control if needed\n    hide_btn.on_click(lambda _: setattr(container.layout, \"display\", \"none\"))\n\n    # 6. wrap in a WidgetControl and add to map\n    ctrl = WidgetControl(widget=container, position=\"topright\")\n    self.add_control(ctrl)\n</code></pre>"},{"location":"maeson/#maeson.maeson.Map.add_earthengine","title":"<code>add_earthengine(self, ee_object, vis_params=None, name='EE Layer')</code>","text":"<p>Adds an Earth Engine layer to the map.</p>"},{"location":"maeson/#maeson.maeson.Map.add_earthengine--parameters","title":"Parameters","text":"<p>ee_object : ee.Image, ee.ImageCollection, or str     If str, will be wrapped as ee.Image; for ImageCollection,     you should reduce it (e.g. .mean()) before passing. vis_params : dict, optional     Visualization parameters, e.g. {\"min\":0,\"max\":3000,\"palette\":[\"blue\",\"red\"]}. name : str, optional     A display name for the layer.</p> Source code in <code>maeson/maeson.py</code> <pre><code>def add_earthengine(self, ee_object, vis_params=None, name=\"EE Layer\"):\n    \"\"\"\n    Adds an Earth Engine layer to the map.\n\n    Parameters\n    ----------\n    ee_object : ee.Image, ee.ImageCollection, or str\n        If str, will be wrapped as ee.Image; for ImageCollection,\n        you should reduce it (e.g. .mean()) before passing.\n    vis_params : dict, optional\n        Visualization parameters, e.g. {\"min\":0,\"max\":3000,\"palette\":[\"blue\",\"red\"]}.\n    name : str, optional\n        A display name for the layer.\n    \"\"\"\n    # 1) Initialize EE if needed\n    try:\n        ee.Initialize()\n    except Exception:\n        ee.Authenticate()\n        ee.Initialize()\n\n    # 2) Wrap strings into Images\n    if isinstance(ee_object, str):\n        ee_object = ee.Image(ee_object)\n\n    # 3) Build the TileLayer via geemap helper\n    vis_params = vis_params or {}\n    tile_layer = geemap.ee_tile_layer(ee_object, vis_params, name)\n\n    # 4) Add to the map\n    self.add_layer(tile_layer)\n\n    # 5) Optionally fit bounds (EE layers often global)\n    # comment this out if you don\u2019t want auto\u2011zoom\n    try:\n        bounds = ee_object.geometry().bounds().getInfo()[\"coordinates\"][0]\n        # bounds is [[lon, lat], \u2026], ipyleaflet wants [[lat, lon], \u2026]\n        latlng_bounds = [[lat, lon] for lon, lat in bounds]\n        self.fit_bounds(latlng_bounds)\n    except Exception:\n        pass\n\n    return tile_layer\n</code></pre>"},{"location":"maeson/#maeson.maeson.Map.add_geojson","title":"<code>add_geojson(self, geojson, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>geojson</code> <code>dict</code> <p>GeoJSON data.</p> required <code>**kwargs</code> <p>Additional arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>maeson/maeson.py</code> <pre><code>def add_geojson(self, geojson, **kwargs):\n    \"\"\"\n    Args:\n        geojson (dict): GeoJSON data.\n        **kwargs: Additional arguments for the GeoJSON layer.\n    \"\"\"\n    \"\"\"Add a GeoJSON layer to the map.\"\"\"\n    geojson_layer = ipyleaflet.GeoJSON(data=geojson, **kwargs)\n    self.add(geojson_layer)\n</code></pre>"},{"location":"maeson/#maeson.maeson.Map.add_image","title":"<code>add_image(self, url, bounds, opacity=1, **kwargs)</code>","text":"<p>Adds an image or animated GIF overlay to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the image or GIF.</p> required <code>bounds</code> <code>tuple</code> <p>Geographic coordinates as ((south, west), (north, east)).</p> required <code>opacity</code> <code>float</code> <p>The transparency level of the overlay (default is 1, fully opaque).</p> <code>1</code> <code>**kwargs</code> <p>Additional keyword arguments for ipyleaflet.ImageOverlay.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If bounds is not provided or is improperly formatted.</p> Source code in <code>maeson/maeson.py</code> <pre><code>def add_image(self, url, bounds, opacity=1, **kwargs):\n    \"\"\"\n    Adds an image or animated GIF overlay to the map.\n\n    Parameters:\n        url (str): The URL of the image or GIF.\n        bounds (tuple): Geographic coordinates as ((south, west), (north, east)).\n        opacity (float, optional): The transparency level of the overlay (default is 1, fully opaque).\n        **kwargs: Additional keyword arguments for ipyleaflet.ImageOverlay.\n\n    Raises:\n        ValueError: If bounds is not provided or is improperly formatted.\n    \"\"\"\n\n    # Validate bounds: It should be a tuple of two coordinate tuples, each of length 2.\n    if not (\n        isinstance(bounds, tuple)\n        and len(bounds) == 2\n        and all(isinstance(coord, tuple) and len(coord) == 2 for coord in bounds)\n    ):\n        raise ValueError(\n            \"bounds must be a tuple in the format ((south, west), (north, east))\"\n        )\n\n    # Create the image overlay using ipyleaflet.ImageOverlay.\n    overlay = ipyleaflet.ImageOverlay(\n        url=url, bounds=bounds, opacity=opacity, **kwargs\n    )\n\n    # Add the overlay to the map.\n    self.add(overlay)\n    self.center = [\n        (bounds[0][0] + bounds[1][0]) / 2,\n        (bounds[0][1] + bounds[1][1]) / 2,\n    ]\n</code></pre>"},{"location":"maeson/#maeson.maeson.Map.add_layer_control","title":"<code>add_layer_control(self, position='topright')</code>","text":"<p>Adds a layer control to the map.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>The position of the layer control. Defaults to 'topright'.</p> <code>'topright'</code> Source code in <code>maeson/maeson.py</code> <pre><code>def add_layer_control(self, position=\"topright\") -&gt; None:\n    \"\"\"Adds a layer control to the map.\n\n    Args:\n        position (str, optional): The position of the layer control. Defaults to 'topright'.\n    \"\"\"\n\n    self.add(ipyleaflet.LayersControl(position=position))\n</code></pre>"},{"location":"maeson/#maeson.maeson.Map.add_raster","title":"<code>add_raster(self, filepath, name=None, colormap='greys', opacity=1, **kwargs)</code>","text":"<p>Add a raster (COG) layer to the map.</p> <p>filepath (str): Path or URL to the cloud-optimized GeoTIFF (COG). name (str, optional): Display name for the layer. colormap (dict or str, optional): A colormap dictionary or a string identifier. opacity (float, optional): Transparency level (default is 1 for fully opaque). **kwargs: Additional keyword arguments to pass to the tile layer generator.</p> Source code in <code>maeson/maeson.py</code> <pre><code>def add_raster(self, filepath, name=None, colormap=\"greys\", opacity=1, **kwargs):\n    \"\"\"\n    Add a raster (COG) layer to the map.\n\n    Parameters:\n    filepath (str): Path or URL to the cloud-optimized GeoTIFF (COG).\n    name (str, optional): Display name for the layer.\n    colormap (dict or str, optional): A colormap dictionary or a string identifier.\n    opacity (float, optional): Transparency level (default is 1 for fully opaque).\n    **kwargs: Additional keyword arguments to pass to the tile layer generator.\n    \"\"\"\n    import rasterio\n    from localtileserver import TileClient, get_leaflet_tile_layer\n\n    # Open the raster with rasterio to inspect metadata.\n    with rasterio.open(filepath) as src:\n        # If no colormap is provided (i.e., None), try extracting it from the raster's first band.\n        if colormap is None:\n            try:\n                colormap = src.colormap(1)\n            except Exception:\n                # Leave colormap unchanged if extraction fails.\n                colormap = \"greys\"\n\n    # Create the tile client from the provided file path.\n    client = TileClient(filepath)\n\n    # Generate the leaflet tile layer using the provided parameters.\n    tile_layer = get_leaflet_tile_layer(\n        client, name=name, colormap=colormap, opacity=opacity, **kwargs\n    )\n\n    # Add the layer to the viewer and update the center and zoom based on the raster metadata.\n    self.add(tile_layer)\n</code></pre>"},{"location":"maeson/#maeson.maeson.Map.add_vector","title":"<code>add_vector(self, vector, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>vector</code> <code>dict</code> <p>Vector data.</p> required <code>**kwargs</code> <p>Additional arguments for the GeoJSON layer.</p> <code>{}</code> Source code in <code>maeson/maeson.py</code> <pre><code>def add_vector(self, vector, **kwargs):\n    \"\"\"\n    Args:\n        vector (dict): Vector data.\n        **kwargs: Additional arguments for the GeoJSON layer.\n    \"\"\"\n    \"\"\"Add a vector layer to the map from Geopandas.\"\"\"\n    vector_layer = ipyleaflet.GeoJSON(data=vector, **kwargs)\n    self.add(vector_layer)\n</code></pre>"},{"location":"maeson/#maeson.maeson.Map.add_video","title":"<code>add_video(self, url, bounds, opacity=1.0, autoplay=True, loop=True, muted=True, **kwargs)</code>","text":"<p>Adds a video overlay to the map using ipyleaflet.VideoOverlay.</p> Source code in <code>maeson/maeson.py</code> <pre><code>def add_video(\n    self,\n    url: str,\n    bounds,\n    opacity: float = 1.0,\n    autoplay: bool = True,\n    loop: bool = True,\n    muted: bool = True,\n    **kwargs,\n):\n    \"\"\"\n    Adds a video overlay to the map using ipyleaflet.VideoOverlay.\n    \"\"\"\n    # 1) Validate &amp; normalize bounds\n    if not (\n        isinstance(bounds, (tuple, list))\n        and len(bounds) == 2\n        and all(isinstance(c, (tuple, list)) and len(c) == 2 for c in bounds)\n    ):\n        raise ValueError(\"bounds must be ((south, west), (north, east))\")\n\n    bounds = [list(bounds[0]), list(bounds[1])]\n\n    # 2) Create the VideoOverlay (url must be a string)\n    overlay = VideoOverlay(\n        url=url,\n        bounds=bounds,\n        opacity=opacity,\n        autoplay=autoplay,\n        loop=loop,\n        muted=muted,\n        **kwargs,\n    )\n\n    # 3) Add to map and fit to the bounds\n    self.add_layer(overlay)  # or self.map.add_layer if you wrap it\n    self.fit_bounds(bounds)\n</code></pre>"},{"location":"maeson/#maeson.maeson.Map.add_wms_layer","title":"<code>add_wms_layer(self, url, layers, name, format, transparent, **kwargs)</code>","text":"<p>Adds a WMS (Web Map Service) layer to the map using ipyleaflet.WMSLayer.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Base WMS endpoint.</p> required <code>layers</code> <code>str</code> <p>Comma-separated layer names.</p> required <code>name</code> <code>str</code> <p>Display name for the layer.</p> required <code>format</code> <code>str</code> <p>Image format (e.g., 'image/png').</p> required <code>transparent</code> <code>bool</code> <p>Whether the WMS layer should be transparent.</p> required <code>**kwargs</code> <p>Additional keyword arguments for ipyleaflet.WMSLayer.</p> <code>{}</code> Source code in <code>maeson/maeson.py</code> <pre><code>def add_wms_layer(self, url, layers, name, format, transparent, **kwargs):\n    \"\"\"\n    Adds a WMS (Web Map Service) layer to the map using ipyleaflet.WMSLayer.\n\n    Parameters:\n        url (str): Base WMS endpoint.\n        layers (str): Comma-separated layer names.\n        name (str): Display name for the layer.\n        format (str): Image format (e.g., 'image/png').\n        transparent (bool): Whether the WMS layer should be transparent.\n        **kwargs: Additional keyword arguments for ipyleaflet.WMSLayer.\n    \"\"\"\n\n    # Create the WMS layer using the provided parameters.\n    wms_layer = WMSLayer(\n        url=url,\n        layers=layers,\n        name=name,\n        format=format,\n        transparent=transparent,\n        **kwargs,\n    )\n\n    # Add the WMS layer to the map.\n    self.add(wms_layer)\n</code></pre>"},{"location":"maeson/#maeson.maeson.Map.center_object","title":"<code>center_object(self, obj, zoom=6, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>obj</code> <code>str or dict</code> <p>Object to center the map on.</p> required <code>zoom</code> <code>int</code> <p>Zoom level.</p> <code>6</code> <code>**kwargs</code> <p>Additional arguments for the map.</p> <code>{}</code> Source code in <code>maeson/maeson.py</code> <pre><code>def center_object(self, obj, zoom=6, **kwargs):\n    \"\"\"\n    Args:\n        obj (str or dict): Object to center the map on.\n        zoom (int): Zoom level.\n        **kwargs: Additional arguments for the map.\n    \"\"\"\n    \"\"\"Center the map on an object.\"\"\"\n    if isinstance(obj, str):\n        obj = ipyleaflet.GeoJSON(data=obj, **kwargs)\n    elif not isinstance(obj, ipyleaflet.Layer):\n        raise ValueError(\"Object must be an instance of ipyleaflet.Layer\")\n    self.center = (obj.location[0], obj.location[1])\n    self.zoom = zoom\n</code></pre>"},{"location":"maeson/#maeson.maeson.Map.layer","title":"<code>layer(self, layer)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>layer</code> <code>str or dict</code> <p>Layer to be added to the map.</p> required <code>**kwargs</code> <p>Additional arguments for the layer.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the layer is not a valid type.</p> Source code in <code>maeson/maeson.py</code> <pre><code>def layer(self, layer) -&gt; None:\n    \"\"\"\n    Args:\n        layer (str or dict): Layer to be added to the map.\n        **kwargs: Additional arguments for the layer.\n    Returns:\n        None\n    Raises:\n        ValueError: If the layer is not a valid type.\n    \"\"\"\n    \"\"\" Convert url to layer\"\"\"\n    if isinstance(layer, str):\n        layer = ipyleaflet.TileLayer(url=layer)\n    elif isinstance(layer, dict):\n        layer = ipyleaflet.GeoJSON(data=layer)\n    elif not isinstance(layer, ipyleaflet.Layer):\n        raise ValueError(\"Layer must be an instance of ipyleaflet.Layer\")\n    return layer\n</code></pre>"},{"location":"maeson/#maeson.maeson.Map.set_center","title":"<code>set_center(self, lat, lon, zoom=6, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>lat</code> <code>float</code> <p>Latitude of the center.</p> required <code>lon</code> <code>float</code> <p>Longitude of the center.</p> required <code>zoom</code> <code>int</code> <p>Zoom level.</p> <code>6</code> <code>**kwargs</code> <p>Additional arguments for the map.</p> <code>{}</code> Source code in <code>maeson/maeson.py</code> <pre><code>def set_center(self, lat, lon, zoom=6, **kwargs):\n    \"\"\"\n    Args:\n        lat (float): Latitude of the center.\n        lon (float): Longitude of the center.\n        zoom (int): Zoom level.\n        **kwargs: Additional arguments for the map.\n    \"\"\"\n    \"\"\"Set the center of the map.\"\"\"\n    self.center = (lat, lon)\n    self.zoom = zoom\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use maeson in a project:</p> <pre><code>import maeson\n</code></pre>"},{"location":"examples/usage/","title":"Usage","text":"In\u00a0[1]: Copied! <pre>import maeson as maeson\n</pre> import maeson as maeson In\u00a0[2]: Copied! <pre>json = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"properties\": {},\n            \"geometry\": {\n                \"coordinates\": [\n                    [\n                        [-0.23448112880515737, 5.569309741857438],\n                        [-0.23448112880515737, 5.536174574314842],\n                        [-0.19047541529968726, 5.536174574314842],\n                        [-0.19047541529968726, 5.569309741857438],\n                        [-0.23448112880515737, 5.569309741857438],\n                    ]\n                ],\n                \"type\": \"Polygon\",\n            },\n        }\n    ],\n}\n</pre> json = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"properties\": {},             \"geometry\": {                 \"coordinates\": [                     [                         [-0.23448112880515737, 5.569309741857438],                         [-0.23448112880515737, 5.536174574314842],                         [-0.19047541529968726, 5.536174574314842],                         [-0.19047541529968726, 5.569309741857438],                         [-0.23448112880515737, 5.569309741857438],                     ]                 ],                 \"type\": \"Polygon\",             },         }     ], } In\u00a0[3]: Copied! <pre># Create map\nm = maeson.Map(zoom=12, center=(5.55, -0.2))\n\n# Add GeoJSON Layer\nm.add_geojson(json, name=\"GeoJSON Layer\", style={\"color\": \"blue\", \"weight\": 2})\n\nm\n</pre> # Create map m = maeson.Map(zoom=12, center=(5.55, -0.2))  # Add GeoJSON Layer m.add_geojson(json, name=\"GeoJSON Layer\", style={\"color\": \"blue\", \"weight\": 2})  m Out[3]: In\u00a0[4]: Copied! <pre>url = \"https://github.com/opengeos/datasets/releases/download/samgeo/tree_image.tif\"\n\nrmap = maeson.Map(zoom=12, center=(5.55, -0.2))\n\n# Add GeoJSON Layer\nrmap.add_raster(filepath=url, name=\"Trees\", colormap=\"viridis\", opacity=0.8)\n\nrmap\n</pre> url = \"https://github.com/opengeos/datasets/releases/download/samgeo/tree_image.tif\"  rmap = maeson.Map(zoom=12, center=(5.55, -0.2))  # Add GeoJSON Layer rmap.add_raster(filepath=url, name=\"Trees\", colormap=\"viridis\", opacity=0.8)  rmap Out[4]: In\u00a0[5]: Copied! <pre>url = \"https://i.imgur.com/06Q1fSz.png\"\nimap = maeson.Map(zoom=4)\n\n# Add Image Layer\nimap.add_image(url, name=\"Image\", bounds=((13, -130), (32, -100)), opacity=0.5)\n\nimap\n</pre> url = \"https://i.imgur.com/06Q1fSz.png\" imap = maeson.Map(zoom=4)  # Add Image Layer imap.add_image(url, name=\"Image\", bounds=((13, -130), (32, -100)), opacity=0.5)  imap Out[5]: In\u00a0[6]: Copied! <pre>import maeson\n\ntest_url = \"https://media.w3.org/2010/05/sintel/trailer.mp4\"\n\nvmap = maeson.Map(zoom=4)\n\n# Add Video Layer\nvmap.add_video(test_url, bounds=[[37.75, -122.5], [37.8, -122.35]])\nvmap\n</pre> import maeson  test_url = \"https://media.w3.org/2010/05/sintel/trailer.mp4\"  vmap = maeson.Map(zoom=4)  # Add Video Layer vmap.add_video(test_url, bounds=[[37.75, -122.5], [37.8, -122.35]]) vmap Out[6]: In\u00a0[7]: Copied! <pre>url = \"http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi\"\n\nwms = maeson.Map(zoom=4, center=(39.5, -98.35))\n\n# Add WMS Layer\nwms.add_wms_layer(\n    url,\n    name=\"WMS Layer\",\n    layers=\"nexrad-n0r-900913\",\n    format=\"image/png\",\n    transparent=True,\n)\nwms\n</pre> url = \"http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi\"  wms = maeson.Map(zoom=4, center=(39.5, -98.35))  # Add WMS Layer wms.add_wms_layer(     url,     name=\"WMS Layer\",     layers=\"nexrad-n0r-900913\",     format=\"image/png\",     transparent=True, ) wms Out[7]: In\u00a0[8]: Copied! <pre>wid = maeson.Map()\n\nwid.add_basemap_dropdown()\n\nwid\n</pre> wid = maeson.Map()  wid.add_basemap_dropdown()  wid Out[8]: In\u00a0[9]: Copied! <pre>from maeson import folmap\n\n# Create map\nm = folmap.Map(zoom=12, center=(5.55, -0.2))\n\n# # Choose a built-in basemap\n# m.add_basemap(name='Topo')\n# m.add_basemap(name='Terrain')\nm.add_basemap(name=\"Satellite\")\n# m.add_basemap(name='Road')\n\n# # Add layer control\nm.add_layer_control()\n\nm\n</pre> from maeson import folmap  # Create map m = folmap.Map(zoom=12, center=(5.55, -0.2))  # # Choose a built-in basemap # m.add_basemap(name='Topo') # m.add_basemap(name='Terrain') m.add_basemap(name=\"Satellite\") # m.add_basemap(name='Road')  # # Add layer control m.add_layer_control()  m Out[9]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[10]: Copied! <pre>map = folmap.Map(zoom=12, center=(5.55, -0.2))\n\n# Add JSON Layer\nmap.add_geojson(json, name=\"GeoJSON Layer\", style={\"color\": \"blue\", \"weight\": 2})\nmap\n</pre> map = folmap.Map(zoom=12, center=(5.55, -0.2))  # Add JSON Layer map.add_geojson(json, name=\"GeoJSON Layer\", style={\"color\": \"blue\", \"weight\": 2}) map Out[10]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[11]: Copied! <pre>import maeson\nfrom maeson.gistory import SceneBuilder\n\n## Raster layer\n# -22.1757, -51.2527\n# https://github.com/opengeos/datasets/releases/download/samgeo/tree_image.tif\n\n## Image layer\n# https://i.imgur.com/06Q1fSz.png\n# ((13, -130), (32, -100))\n\n## Video layer\n# https://www.mapbox.com/bites/00188/patricia_nasa.webm\n# ((13, -130), (32, -100))\n\n## WMS layer\n# http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi\n# (39.5, -98.35)\n\n\nm = maeson.Map(center=(0, 0), zoom=2)\nbuilder = SceneBuilder(m)\nbuilder.display()\n</pre> import maeson from maeson.gistory import SceneBuilder  ## Raster layer # -22.1757, -51.2527 # https://github.com/opengeos/datasets/releases/download/samgeo/tree_image.tif  ## Image layer # https://i.imgur.com/06Q1fSz.png # ((13, -130), (32, -100))  ## Video layer # https://www.mapbox.com/bites/00188/patricia_nasa.webm # ((13, -130), (32, -100))  ## WMS layer # http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi # (39.5, -98.35)   m = maeson.Map(center=(0, 0), zoom=2) builder = SceneBuilder(m) builder.display()"},{"location":"examples/usage/#example-code-usage","title":"Example Code Usage\u00b6","text":""},{"location":"examples/usage/#ipyleaflet-functionality","title":"ipyleaflet Functionality\u00b6","text":""},{"location":"examples/usage/#vector-data","title":"Vector Data\u00b6","text":""},{"location":"examples/usage/#raster-data","title":"Raster Data\u00b6","text":""},{"location":"examples/usage/#imagegifs","title":"Image/GIFs\u00b6","text":""},{"location":"examples/usage/#video-layers","title":"Video Layers\u00b6","text":""},{"location":"examples/usage/#wms-layers","title":"WMS Layers\u00b6","text":""},{"location":"examples/usage/#basemap-widget","title":"Basemap Widget\u00b6","text":""},{"location":"examples/usage/#folium-functionality","title":"Folium Functionality\u00b6","text":""},{"location":"examples/usage/#gistory","title":"gistory\u00b6","text":""},{"location":"examples/usage/#scenebuilder","title":"SceneBuilder\u00b6","text":""}]}